<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-09-25 Sat 02:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>unpackaged.el</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/darksun.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/hideshow.css"/>
<script type="text/javascript" src="export/styles/darksun/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/darksun.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/hideshow.js"></script>
<script type="text/javascript" src="export/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">unpackaged.el</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Usage">Usage</a></li>
<li><a href="#Faces%2C%20fonts">Faces, fonts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="faces">faces</span>&#xa0;<span class="fonts">fonts</span></span></a>
<ul>
<li><a href="#font-compare">font-compare</a></li>
</ul>
</li>
<li><a href="#Buffers">Buffers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="buffers">buffers</span></span></a>
<ul>
<li><a href="#ibuffer">ibuffer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ibuffer">ibuffer</span></span></a>
<ul>
<li><a href="#Filter%20groups">Filter groups</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Customization">Customization</a>
<ul>
<li><a href="#Expand%20all%20options%27%20documentation">Expand all options' documentation</a></li>
<li><a href="#Set%20value%20of%20customization%20option%20at%20point">Set value of customization option at point</a></li>
<li><a href="#Customize%20theme%20faces">Customize theme faces</a></li>
</ul>
</li>
<li><a href="#Elfeed">Elfeed&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Elfeed">Elfeed</span></span></a>
<ul>
<li><a href="#Filter%20hydra">Filter hydra</a></li>
</ul>
</li>
<li><a href="#Meta">Meta&#xa0;&#xa0;&#xa0;<span class="tag"><span class="meta">meta</span></span></a></li>
<li><a href="#Misc">Misc</a>
<ul>
<li><a href="#Define%20a%20%22chooser%22%20command">Define a "chooser" command</a></li>
<li><a href="#Obfuscate%20buffer%20text%20with%20%2Florem%20ipsum%2F%20words">Obfuscate buffer text with <i>lorem ipsum</i> words</a></li>
<li><a href="#Track%20metadata%20from%20MPRIS-supporting%20media%20player">Track metadata from MPRIS-supporting media player&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DBus">DBus</span></span></a></li>
</ul>
</li>
<li><a href="#Org">Org&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Org">Org</span></span></a>
<ul>
<li><a href="#Agenda">Agenda&#xa0;&#xa0;&#xa0;<span class="tag"><span class="agenda">agenda</span></span></a>
<ul>
<li><a href="#Agenda%20for%20subtree%20or%20region">Agenda for subtree or region</a></li>
<li><a href="#Agenda%20for%20outline%20path">Agenda for outline path</a></li>
<li><a href="#Agenda%20previews">Agenda previews</a></li>
</ul>
</li>
<li><a href="#Miscellaneous">Miscellaneous</a>
<ul>
<li><a href="#Convert%20Elisp%20to%20Org%20format">Convert Elisp to Org format&#xa0;&#xa0;&#xa0;<span class="tag"><span class="meta">meta</span></span></a></li>
</ul>
</li>
<li><a href="#Attachments">Attachments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="attachments">attachments</span></span></a>
<ul>
<li><a href="#Download%20and%20attach%20remote%20files">Download and attach remote files</a></li>
</ul>
</li>
<li><a href="#Exporting">Exporting</a>
<ul>
<li><a href="#Export%20to%20HTML%20with%20%2Fuseful%2F%20anchors">Export to HTML with <i>useful</i> anchors</a></li>
</ul>
</li>
<li><a href="#Editing">Editing</a>
<ul>
<li><a href="#Ensure%20blank%20lines%20between%20headings%20and%20before%20contents">Ensure blank lines between headings and before contents</a></li>
<li><a href="#Surround%20region%20with%20emphasis%20or%20syntax%20characters">Surround region with emphasis or syntax characters</a></li>
<li><a href="#Read-only%20trees">Read-only trees</a></li>
<li><a href="#~org-return-dwim~"><code>org-return-dwim</code></a></li>
</ul>
</li>
<li><a href="#Display">Display</a>
<ul>
<li><a href="#Force%20monospace%20face%20in%20tables">Force monospace face in tables</a></li>
<li><a href="#Outline%20number%20overlays">Outline number overlays</a></li>
</ul>
</li>
<li><a href="#Refiling">Refiling</a>
<ul>
<li><a href="#Refile%20to%20datetree%20file%20using%20earliest%2Flatest%20timestamp%20in%20entry">Refile to datetree file using earliest/latest timestamp in entry</a></li>
</ul>
</li>
<li><a href="#Sorting">Sorting</a>
<ul>
<li><a href="#Recursive%20sorting%20by%20multiple%20keys">Recursive sorting by multiple keys</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Packages">Packages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="packages">packages</span></span></a>
<ul>
<li><a href="#Delete%20all%20installed%20versions%20of%20a%20package">Delete all installed versions of a package</a></li>
<li><a href="#Reload%20a%20package%27s%20features">Reload a package's features</a></li>
<li><a href="#Upgrade%20a%20~quelpa-use-package~%20form%27s%20package">Upgrade a <code>quelpa-use-package</code> form's package</a></li>
<li><a href="#Upgrade%20one%20package%20in%20the%20package%20menu">Upgrade one package in the package menu</a></li>
</ul>
</li>
<li><a href="#Programming">Programming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="programming">programming</span></span></a>
<ul>
<li><a href="#Flexibly%20fill%2Funfill%20paragraphs">Flexibly fill/unfill paragraphs</a></li>
<li><a href="#~iedit~"><code>iedit</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="iedit">iedit</span>&#xa0;<span class="refactoring">refactoring</span></span></a>
<ul>
<li><a href="#~iedit-scoped~"><code>iedit-scoped</code></a></li>
<li><a href="#~iedit-or-flyspell~"><code>iedit-or-flyspell</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="flyspell">flyspell</span>&#xa0;<span class="spell_checking">spell_checking</span></span></a></li>
</ul>
</li>
<li><a href="#Sort%20sexps">Sort sexps</a></li>
</ul>
</li>
<li><a href="#Regular%20expressions">Regular expressions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="regular_expressions">regular_expressions</span></span></a>
<ul>
<li><a href="#query-replace-rx">query-replace-rx</a></li>
</ul>
</li>
<li><a href="#Version%20control">Version control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="version_control">version_control</span></span></a>
<ul>
<li><a href="#Magit">Magit&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Magit">Magit</span></span></a>
<ul>
<li><a href="#Improved%20~magit-status~%20command">Improved <code>magit-status</code> command</a></li>
<li><a href="#magit-log%20date%20headers">magit-log date headers</a></li>
<li><a href="#Save%20buffer%20and%20show%20changes%20in%20Magit%20status">Save buffer and show changes in Magit status</a></li>
</ul>
</li>
<li><a href="#~smerge-mode~"><code>smerge-mode</code></a>
<ul>
<li><a href="#Hydra">Hydra</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Web">Web&#xa0;&#xa0;&#xa0;<span class="tag"><span class="web">web</span></span></a>
<ul>
<li><a href="#feed-for-url">feed-for-url&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RSS">RSS</span>&#xa0;<span class="Atom">Atom</span>&#xa0;<span class="XML">XML</span></span></a></li>
</ul>
</li>
<li><a href="#License">License</a></li>
</ul>
</div>
</div>
<a href=https://alphapapa.github.io/dont-tread-on-emacs/><img src="images/dont-tread-on-emacs-150.png" align="right"></a>

<p>
A collection of useful Emacs Lisp code that isn't substantial enough to be packaged.  This code will be maintained here so that it can be updated and improved over time.
</p>

<p>
This can be viewed directly on the <a href="http://github.com/alphapapa/unpackaged.el">repository</a> or as <a href="http://alphapapa.github.io/unpackaged.el">HTML</a>.
</p>

<p>
Contributions welcome!
</p>

<p>
Functions in this file generally use these helper packages:
</p>

<ul class="org-ul">
<li><a href="https://github.com/magnars/dash.el">dash.el</a> (including <code>dash-functional</code>)</li>
<li><a href="https://github.com/magnars/s.el">s.el</a></li>
<li><a href="https://github.com/jwiegley/use-package">use-package</a></li>
</ul>

<div id="outline-container-Usage" class="outline-2">
<h2 id="Usage">Usage</h2>
<div class="outline-text-2" id="text-Usage">
<p>
There are two ways to use the code in this "unpackage":
</p>

<dl class="org-dl">
<dt>Buffet</dt><dd>Choose the the parts you want and copy them into your init files.</dd>
<dt>Whole-hog</dt><dd>Load the file <code>unpackaged.el</code>, which is tangled from this Org file, e.g. <code>(require 'unpackaged)</code>.</dd>
</dl>

<p>
In general, the author will attempt to avoid code that modifies Emacs state by simply loading the tangled "unpackage," but this is not strictly guaranteed.  Please report any problems.
</p>

<p>
An easy way to "whole-hog it" is to use <a href="https://framagit.org/steckerhalter/quelpa-use-package">quelpa-use-package</a> like this:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package unpackaged
  :quelpa (unpackaged :fetcher github :repo "alphapapa/unpackaged.el"))
</pre>
</div>
</div>
</div>

<div id="outline-container-Faces%2C%20fonts" class="outline-2">
<h2 id="Faces%2C%20fonts">Faces, fonts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="faces">faces</span>&#xa0;<span class="fonts">fonts</span></span></h2>
<div class="outline-text-2" id="text-Faces%2C%20fonts">
</div>
<div id="outline-container-font-compare" class="outline-3">
<h3 id="font-compare">font-compare</h3>
<div class="outline-text-3" id="text-font-compare">
<p>
Compare <code>TEXT</code> displayed in <code>FONTS</code>.  <code>FONTS</code> is a list of font specs.
</p>

<p>
Interactively, prompt for <code>TEXT</code>, using <code>lorem-ipsum</code> text if nil or the empty string, and select <code>FONTS</code> with <code>x-select-font</code>, pressing Cancel to stop selecting fonts.
</p>

<p>
<b>Requires:</b>
</p>
<ul class="org-ul">
<li><a href="https://github.com/jschaf/emacs-lorem-ipsum">emacs-lorem-ipsum</a></li>
</ul>

<p>

</p>

<div class="org-src-container">
<pre class="src src-elisp">(require 'seq)

(defvar lorem-ipsum-text)

;;;###autoload
(defun unpackaged/font-compare (text fonts)
  "Compare TEXT displayed in FONTS.
If TEXT is nil, use `lorem-ipsum' text.  FONTS is a list of font
family strings and/or font specs.

Interactively, prompt for TEXT, using `lorem-ipsum' if left
empty, and select FONTS with `x-select-font', pressing Cancel to
stop selecting fonts."
  (interactive (list (pcase (read-string "Text: ")
		       ("" nil)
		       (else else))
		     ;; `x-select-font' calls quit() when Cancel is pressed, so we use
		     ;; `inhibit-quit', `with-local-quit', and `quit-flag' to avoid that.
		     (let ((inhibit-quit t))
		       (cl-loop for font = (with-local-quit
					     (x-select-font))
				while font
				collect font into fonts
				finally do (setf quit-flag nil)
				finally return fonts))))
  (setq text (or text (s-word-wrap 80 (s-join " " (progn
						    (require 'lorem-ipsum)
						    (seq-random-elt lorem-ipsum-text))))))
  (with-current-buffer (get-buffer-create "*Font Compare*")
    (erase-buffer)
    (--each fonts
      (let ((family (cl-typecase it
		      (font (symbol-name (font-get it :family)))
		      (string it))))
	(insert family ": "
		(propertize text
			    'face (list :family family))
		"\n\n")))
    (pop-to-buffer (current-buffer))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Buffers" class="outline-2">
<h2 id="Buffers">Buffers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="buffers">buffers</span></span></h2>
<div class="outline-text-2" id="text-Buffers">
</div>
<div id="outline-container-ibuffer" class="outline-3">
<h3 id="ibuffer">ibuffer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ibuffer">ibuffer</span></span></h3>
<div class="outline-text-3" id="text-ibuffer">
<div class="org-src-container">
<pre class="src src-elisp">;;; ibuffer

</pre>
</div>
</div>

<div id="outline-container-Filter%20groups" class="outline-4">
<h4 id="Filter%20groups">Filter groups</h4>
<div class="outline-text-4" id="text-Filter%20groups">
<p>
These commands toggle and move filter groups.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(require 'ibuffer)
(require 'ibuf-ext)

;;;###autoload
(defun unpackaged/ibuffer-toggle-all-filter-groups (toggle-empty)
  "Toggle all filter groups.
With prefix, toggle `ibuffer-show-empty-filter-groups'."
  (interactive "P")
  (if toggle-empty
      (progn
	(setf ibuffer-show-empty-filter-groups (not ibuffer-show-empty-filter-groups))
	(ibuffer-update nil))
    (save-excursion
      (goto-char (point-min))
      (ibuffer-forward-filter-group)
      (let ((start (point)))
	(forward-char)
	(while (not (&lt;= (point) start))
	  (ibuffer-toggle-filter-group)
	  (ibuffer-forward-filter-group))))))

;;;###autoload
(defun unpackaged/ibuffer-filter-group-move-down ()
  "Move filter group at point down."
  (interactive)
  (unpackaged/ibuffer-filter-group-move 'down))

;;;###autoload
(defun unpackaged/ibuffer-filter-group-move-up ()
  "Move filter group at point up."
  (interactive)
  (unpackaged/ibuffer-filter-group-move 'up))

(defun unpackaged/ibuffer-filter-group-move (direction)
  "Move filter group at point in DIRECTION, either `up' or `down'."
  (ibuffer-kill-line)
  (pcase-exhaustive direction
    ('down (ibuffer-forward-filter-group))
    ('up (ibuffer-backward-filter-group)))
  (ibuffer-yank))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-Customization" class="outline-2">
<h2 id="Customization">Customization</h2>
<div class="outline-text-2" id="text-Customization">
<div class="org-src-container">
<pre class="src src-elisp">;;; Customization

</pre>
</div>
</div>

<div id="outline-container-Expand%20all%20options%27%20documentation" class="outline-3">
<h3 id="Expand%20all%20options%27%20documentation">Expand all options' documentation</h3>
<div class="outline-text-3" id="text-Expand%20all%20options%27%20documentation">
<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/custom-toggle-all-more-hide ()
  "Toggle all \"More/Hide\" widgets in current buffer."
  (interactive)
  (widget-map-buttons (lambda (widget _)
			(pcase (widget-get widget :off)
			  ("More" (widget-apply-action widget)))
			nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-Set%20value%20of%20customization%20option%20at%20point" class="outline-3">
<h3 id="Set%20value%20of%20customization%20option%20at%20point">Set value of customization option at point</h3>
<div class="outline-text-3" id="text-Set%20value%20of%20customization%20option%20at%20point">
<p>
In <code>Customize</code> buffers, pressing <code>C-c C-c</code> offers to set all variables in the buffer, which isn't always what I want when point is on one option.  This binds that key to a new function in <code>custom-field-keymap</code>, which is only active when point is on an editable field.  The function sets only the current option.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package cus-edit
  :general
  (:keymaps 'custom-field-keymap
	    "C-c C-c" (defun unpackaged/custom-set-at-point ()
			"Set current value of widget at point."
			(interactive)
			(cl-labels ((find-widget (widget property)
						 (if (widget-get widget property)
						     widget
						   (find-widget (widget-get widget :parent) property))))
			  (when-let* ((widget (find-widget (widget-at) :custom-set)))
			    (when (eq (widget-get widget :custom-state) 'modified)
			      (widget-apply widget :custom-set)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Customize%20theme%20faces" class="outline-3">
<h3 id="Customize%20theme%20faces">Customize theme faces</h3>
<div class="outline-text-3" id="text-Customize%20theme%20faces">
<p>
Customize <code>THEME</code> with <code>FACES</code>.  Advises <code>enable-theme</code> with a function that customizes <code>FACES</code> when <code>THEME</code> is enabled.  If <code>THEME</code> is already enabled, also applies faces immediately.  Calls <code>custom-theme-set-faces</code>, which see.
</p>

<p>
For example:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(unpackaged/customize-theme-faces 'doom-solarized-dark
  `(font-lock-builtin-face ((t :weight bold :foreground "#268bd2")))
  `(font-lock-comment-face ((t :weight bold :slant italic :foreground ,(doom-color 'comments))))
  `(org-list-dt ((t :weight bold)))
  `(org-link ((t :inherit link :foreground ,(doom-color 'cyan) :weight normal)))
  `(org-date ((t :foreground ,(doom-color 'yellow) :weight bold)))
  `(org-table ((t :foreground ,(doom-color 'green) :family "monospace")))
  `(org-block-begin-line ((t :weight bold :foreground ,(doom-color 'comments) :background ,(doom-color 'base2) :family "monospace")))
  `(org-meta-line ((t :weight bold :foreground ,(doom-color 'comments) :family "monospace"))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/customize-theme-faces (theme &amp;rest faces)
  "Customize THEME with FACES.
Advises `enable-theme' with a function that customizes FACES when
THEME is enabled.  If THEME is already enabled, also applies
faces immediately.  Calls `custom-theme-set-faces', which see."
  (declare (indent defun))
  (when (member theme custom-enabled-themes)
    ;; Theme already enabled: apply faces now.
    (let ((custom--inhibit-theme-enable nil))
      (apply #'custom-theme-set-faces theme faces)))
  (let ((fn-name (intern (concat "unpackaged/enable-theme-advice-for-" (symbol-name theme)))))
    ;; Apply advice for next time theme is enabled.
    (fset fn-name
	  (lambda (enabled-theme)
	    (when (eq enabled-theme theme)
	      (let ((custom--inhibit-theme-enable nil))
		(apply #'custom-theme-set-faces theme faces)))))
    (advice-remove #'enable-theme fn-name)
    (advice-add #'enable-theme :after fn-name)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Elfeed" class="outline-2">
<h2 id="Elfeed">Elfeed&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Elfeed">Elfeed</span></span></h2>
<div class="outline-text-2" id="text-Elfeed">
<div class="org-src-container">
<pre class="src src-elisp">;;; Elfeed

</pre>
</div>
</div>

<div id="outline-container-Filter%20hydra" class="outline-3">
<h3 id="Filter%20hydra">Filter hydra</h3>
<div class="outline-text-3" id="text-Filter%20hydra">
<p>
<b>Requires:</b> <a href="https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra-define">pretty-hydra</a>
</p>

<p>
This macro defines a <a href="https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra-define">pretty-hydra</a> that makes it easy to toggle Elfeed filter components, which allows quickly building a custom filter with a few keystrokes.  You can add your own favorite tokens to the hydra with your own keybindings, and it also provides completion for feeds and tags from the Elfeed database.
</p>

<p>
This animation shows the example hydra from the docstring:
</p>

<p>

</p>

<p>
The example hydra:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(unpackaged/elfeed-search-view-hydra-define my/elfeed-search-view-hydra
  (:foreign-keys warn)
  ("Views"
   (("@" :complete-age "Date")
    ("d" nil))
   "Status"
   (("su" "+unread"))
   "Feed"
   (("f TAB" :complete-feed "Choose")
    ("fE" "=Planet Emacslife" "Planet Emacslife"))
   "Tags"
   (("t TAB" :complete-tag "Choose")
    ("te" "+Emacs"))
   ""
   (("tn" "+news"))))
</pre>
</div>

<p>
The macro and function:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defvar elfeed-search-filter)

(cl-defmacro unpackaged/elfeed-search-view-hydra-define (name body views)
  "Define a pretty hydra named NAME with BODY and VIEWS.
VIEWS is a plist: in it, each property is a string which becomes
a column header in the hydra, and each value is a list of lists
in this format: (KEY COMPONENT &amp;optional LABEL).

The KEY is a key sequence passed to `kbd', like \"s\" or \"S
TAB\".  The COMPONENT is an Elfeed filter component, which may
begin with \"+\" or \"=\", and in which spaces are automatically
escaped as required by Elfeed.  The LABEL, if present, is a
string displayed next to the KEY; if absent, COMPONENT is
displayed.

In the resulting hydra, when KEY is pressed, the COMPONENT is
toggled in `elfeed-search-filter'.  It is toggled between three
states: normal, inverse, and absent.  For example, the component
\"+tag\" cycles between three states in the filter: \"+tag\",
\"-tag\", and \"\".  The appropriate inverse prefix is used
according to the component's prefix (i.e. for \"=\", the inverse
is \"~\", and for \"\" (a plain regexp), \"!\" is used).

These special components may be used to read choices from the
Elfeed database with completion and toggle them:

  :complete-age   Completes and sets the age token.
  :complete-feed  Completes and toggles a feed token.
  :complete-tag   Completes and toggles a tag token.
  nil             Sets default filter.

A complete example:

  (unpackaged/elfeed-search-view-hydra-define my/elfeed-search-view-hydra
    (:foreign-keys warn)
    (\"Views\"
     ((\"@\" :complete-age \"Date\")
      (\"d\" nil))
     \"Status\"
     ((\"su\" \"+unread\"))
     \"Feed\"
     ((\"f TAB\" :complete-feed \"Choose\")
      (\"fE\" \"=Planet Emacslife\" \"Planet Emacslife\"))
     \"Tags\"
     ((\"t TAB\" :complete-tag \"Choose\")
      (\"te\" \"+Emacs\"))
     \"\"
     ((\"tn\" \"+news\"))))"
  (declare (indent defun))
  (cl-labels ((escape-spaces (string)
			     ;; Return STRING with spaces escaped with "\s-".  Necessary
			     ;; because Elfeed treats all literal spaces as separating tokens.
			     (replace-regexp-in-string (rx space) "\\s-" string t t)))
    (let* ((completion-fns
	    (list (cons :complete-age
			(lambda ()
			  (interactive)
			  (save-match-data
			    (let* ((date-regexp (rx (group (or bos blank) "@" (1+ digit) (1+ (not blank)))))
				   (date-tag (when (string-match date-regexp elfeed-search-filter)
					       (match-string 1 elfeed-search-filter))))
			      (elfeed-search-set-filter
			       (replace-regexp-in-string date-regexp (read-string "Date: " date-tag)
							 elfeed-search-filter t t))))))
		  (cons :complete-feed
			'(concat "=" (replace-regexp-in-string
				      (rx space) "\\s-"
				      (-&gt;&gt; (hash-table-values elfeed-db-feeds)
					   (--map (elfeed-meta it :title))
					   (completing-read "Feed: ")
					   regexp-quote) t t)))
		  (cons :complete-tag
			'(concat "+" (completing-read "Tag: " (elfeed-db-get-all-tags))))))
	   (body (append '(:title elfeed-search-filter :color pink :hint t :quit-key "q")
			 body))
	   (heads (cl-loop for (heading views) on views by #'cddr
			   collect heading
			   collect (cl-loop for (key component label) in views
					    collect
					    `(,key
					      ,(cl-typecase component
						 ((and function (not null))
						  ;; I don't understand why nil matches
						  ;; (or lambda function), but it does,
						  ;; so we have to account for it.  See
						  ;; (info-lookup-symbol 'cl-typep).
						  `(funcall ,component))
						 (string
						  `(elfeed-search-set-filter
						    (unpackaged/elfeed-search-filter-toggle-component
						     elfeed-search-filter ,(escape-spaces component))))
						 (otherwise
						  `(elfeed-search-set-filter
						    ,(when component
						       `(unpackaged/elfeed-search-filter-toggle-component
							 elfeed-search-filter ,component)))))
					      ,(or label component "Default"))))))
      ;; I am so glad I discovered `cl-sublis'.  I tried several variations of `cl-labels' and
      ;; `cl-macrolet' and `cl-symbol-macrolet', but this is the only way that has worked.
      (setf heads (cl-sublis completion-fns heads))
      `(pretty-hydra-define ,name ,body
	 ,heads))))

(cl-defun unpackaged/elfeed-search-filter-toggle-component (string component)
  "Return STRING (which should be `elfeed-search-filter') having toggled COMPONENT.
Tries to intelligently handle components based on their prefix:
+tag, =feed, regexp."
  (save-match-data
    (cl-labels ((toggle (component +prefix -prefix string)
			(let ((+pat (rx-to-string `(seq (or bos blank)
							(group ,+prefix ,component)
							(or eos blank))))
			      (-pat (rx-to-string `(seq (group (or bos (1+ blank)) ,-prefix ,component)
							(or eos blank)))))
			  ;; TODO: In newer Emacs versions, the `rx' pattern `literal'
			  ;; evaluates at runtime in `pcase' expressions.
			  (pcase string
			    ((pred (string-match +pat)) (rm (concat -prefix component) string))
			    ((pred (string-match -pat)) (rm "" string))
			    (_ (concat string " " +prefix component)))))
		(rm (new string) (replace-match new t t string 1)))
      (pcase component
	((rx bos "+" (group (1+ anything)))
	 (toggle (match-string 1 component) "+" "-" string))
	((rx bos "=" (group (1+ anything)))
	 (toggle (match-string 1 component) "=" "~" string))
	(_ (toggle component "" "!" string))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Meta" class="outline-2">
<h2 id="Meta">Meta&#xa0;&#xa0;&#xa0;<span class="tag"><span class="meta">meta</span></span></h2>
<div class="outline-text-2" id="text-Meta">
<p>
Code used to help maintain this document.  (Note: These links don't work in GitHub's renderer.)
</p>

<ul class="org-ul">
<li></li>
</ul>
</div>
</div>

<div id="outline-container-Misc" class="outline-2">
<h2 id="Misc">Misc</h2>
<div class="outline-text-2" id="text-Misc">
</div>
<div id="outline-container-Define%20a%20%22chooser%22%20command" class="outline-3">
<h3 id="Define%20a%20%22chooser%22%20command">Define a "chooser" command</h3>
<div class="outline-text-3" id="text-Define%20a%20%22chooser%22%20command">
<p>
This macro defines a "chooser" command, which allows the user to use completion to choose a lambda function to run.  It's helpful for grouping related functions together, or swapping between choices which can be set from Lisp code.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defmacro unpackaged/define-chooser (name &amp;rest choices)
  "Define a chooser command NAME offering CHOICES.
Each of CHOICES should be a list, the first of which is the
choice's name, and the rest of which is its body forms."
  (declare (indent defun))
  ;; Avoid redefining existing, non-chooser functions.
  (cl-assert (or (not (fboundp name))
		 (get name :unpackaged/define-chooser)))
  (let* ((choice-names (mapcar #'car choices))
	 (choice-list (--map (cons (car it) `(lambda (&amp;rest args)
					       ,@(cdr it)))
			     choices))
	 (prompt (format "Choose %s: " name))
	 (docstring (concat "Choose between: " (s-join ", " choice-names))))
    `(progn
       (defun ,name ()
	 ,docstring
	 (interactive)
	 (let* ((choice-name (completing-read ,prompt ',choice-names)))
	   (funcall (alist-get choice-name ',choice-list nil nil #'equal))))
       (put ',name :unpackaged/define-chooser t))))
</pre>
</div>

<p>
This example shows using it to set <a href="https://github.com/alphapapa/prism.el">prism.el</a> themes by calling <code>prism-set-colors</code> in each choice.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(unpackaged/define-chooser ap/prism-theme
  ("Keen"
   (prism-set-colors :num 16
     :local (pcase current-prefix-arg
	      ('(16) 'reset)
	      (_ current-prefix-arg))
     :desaturations (cl-loop for i from 0 below 16
			     collect (* i 2.5))
     :lightens (cl-loop for i from 0 below 16
			collect (* i 2.5))
     :colors (list "sandy brown" "dodgerblue" "medium sea green")
     :comments-fn (lambda (color)
		    (prism-blend color (face-attribute 'font-lock-comment-face :foreground)
				 0.25))
     :strings-fn (lambda (color)
		   (prism-blend color "white" 0.5))))
  ("Solarized: rainbow"
   (prism-set-colors :num 24
     :local (pcase current-prefix-arg
	      ('(16) 'reset)
	      (_ current-prefix-arg))
     :lightens '(5 15 25)
     :colors (solarized-with-color-variables 'dark
	       (list red orange yellow green blue cyan violet magenta))
     :comments-fn (lambda (color)
		    (--&gt; color
			 (color-desaturate-name it 50)))
     :strings-fn (lambda (color)
		   (prism-blend color "white" 0.5))))
  ("Solarized: rainbow inverted"
   (prism-set-colors :num 24
     :local (pcase current-prefix-arg
	      ('(16) 'reset)
	      (_ current-prefix-arg))
     :lightens '(5 15 25)
     :colors (solarized-with-color-variables 'dark
	       (nreverse (list red orange yellow green blue cyan violet magenta)))
     :comments-fn (lambda (color)
		    (--&gt; color
			 (color-desaturate-name it 50)))
     :strings-fn (lambda (color)
		   (prism-blend color "white" 0.5)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Obfuscate%20buffer%20text%20with%20%2Florem%20ipsum%2F%20words" class="outline-3">
<h3 id="Obfuscate%20buffer%20text%20with%20%2Florem%20ipsum%2F%20words">Obfuscate buffer text with <i>lorem ipsum</i> words</h3>
<div class="outline-text-3" id="text-Obfuscate%20buffer%20text%20with%20%2Florem%20ipsum%2F%20words">
<p>
When taking a screenshot, one may not want to reveal the text that is in it.  Rather than editing the screenshot to hide the text, one can use this command to temporarily overlay text in a buffer with <i>lorem ipsum</i> words, which present a similar appearance without any meaning.
</p>

<p>
<b>Requires:</b>
</p>
<ul class="org-ul">
<li><a href="https://github.com/jschaf/emacs-lorem-ipsum">emacs-lorem-ipsum</a></li>
</ul>

<p>

</p>

<div class="org-src-container">
<pre class="src src-elisp">(defcustom unpackaged/lorem-ipsum-overlay-exclude nil
  "List of regexps to exclude from `unpackaged/lorem-ipsum-overlay'."
  :type '(repeat regexp))

;;;###autoload
(defun unpackaged/lorem-ipsum-overlay (&amp;optional replace-p)
  "Overlay all text in current buffer with \"lorem ipsum\" text.
When called again, remove overlays.  Useful for taking
screenshots without revealing buffer contents.

If REPLACE-P is non-nil (interactively, with prefix), replace
buffer contents rather than overlaying them.  When a buffer is
very large and would have so many overlays that performance would
be prohibitively slow, you may replace the buffer contents
instead.  (Of course, be careful about saving the buffer after
replacing its contents.)

Each piece of non-whitespace text in the buffer is compared with
regexps in `unpackaged/lorem-ipsum-overlay-exclude', and ones
that match are not overlaid.  Note that the regexps are compared
against the entire non-whitespace token, up-to and including the
preceding whitespace, but only the alphabetic part of the token
is overlaid.  For example, in an Org buffer, a line that starts
with:

  #+TITLE: unpackaged.el

could be matched against the exclude regexp (in `rx' syntax):

  (rx (or bol bos blank) \"#+\" (1+ alnum) \":\" (or eol eos blank))

And the line would be overlaid like:

  #+TITLE: parturient.et"
  (interactive "P")
  (require 'lorem-ipsum)
  (let ((ovs (overlays-in (point-min) (point-max))))
    (if (cl-loop for ov in ovs
		 thereis (overlay-get ov :lorem-ipsum-overlay))
	;; Remove overlays.
	(dolist (ov ovs)
	  (when (overlay-get ov :lorem-ipsum-overlay)
	    (delete-overlay ov)))
      ;; Add overlays.
      (let ((lorem-ipsum-words (--&gt; lorem-ipsum-text
				    (-flatten it) (apply #'concat it)
				    (split-string it (rx (or space punct)) 'omit-nulls)))
	    (case-fold-search nil))
	(cl-labels ((overlay-group (group)
				   (let* ((beg (match-beginning group))
					  (end (match-end group))
					  (replacement-word (lorem-word (match-string group)))
					  (ov (make-overlay beg end)))
				     (when replacement-word
				       (overlay-put ov :lorem-ipsum-overlay t)
				       (overlay-put ov 'display replacement-word))))
		    (replace-group (group)
				   (let* ((beg (match-beginning group))
					  (end (match-end group))
					  (replacement-word (lorem-word (match-string group))))
				     (when replacement-word
				       (setf (buffer-substring beg end) replacement-word))))
		    (lorem-word (word)
				(if-let* ((matches (lorem-matches (length word))))
				    (apply-case word (downcase (seq-random-elt matches)))
				  ;; Word too long: compose one.
				  (apply-case word (downcase (compose-word (length word))))))
		    (lorem-matches (length &amp;optional (comparator #'=))
				   (cl-loop for liw in lorem-ipsum-words
					    when (funcall comparator (length liw) length)
					    collect liw))
		    (apply-case (source target)
				(cl-loop for sc across-ref source
					 for tc across-ref target
					 when (not (string-match-p (rx lower) (char-to-string sc)))
					 do (setf tc (string-to-char (upcase (char-to-string tc)))))
				target)
		    (compose-word (length)
				  (cl-loop while (&gt; length 0)
					   for word = (seq-random-elt (lorem-matches length #'&lt;=))
					   concat word
					   do (cl-decf length (length word)))))
	  (save-excursion
	    (goto-char (point-min))
	    (while (re-search-forward (rx (group (1+ (or bol bos blank (not alpha)))
						 (0+ (not (any alpha blank)))
						 (group (1+ alpha))
						 (0+ (not (any alpha blank)))))
				      nil t)
	      (unless (cl-member (match-string 0) unpackaged/lorem-ipsum-overlay-exclude
				 :test (lambda (string regexp)
					 (string-match-p regexp string)))
		(if replace-p
		    (replace-group 2)
		  (overlay-group 2)))
	      (goto-char (match-end 2)))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Track%20metadata%20from%20MPRIS-supporting%20media%20player" class="outline-3">
<h3 id="Track%20metadata%20from%20MPRIS-supporting%20media%20player">Track metadata from MPRIS-supporting media player&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DBus">DBus</span></span></h3>
<div class="outline-text-3" id="text-Track%20metadata%20from%20MPRIS-supporting%20media%20player">
<p>
Return the artist, album, and title of the track playing in MPRIS-supporting player.  Returns a string in format <code>ARTIST - ~ALBUM~: ~TITLE~ [PLAYER]</code>.  If no track is playing, returns nil.  If more than one player is playing, uses the first one found in DBus.  If <code>PLAYER</code> is non-nil, include the name of the player in the output string.
</p>

<p>
DBus is not a straightforward system to work with, so this may serve as a useful example, or save someone the trouble of figuring out how to get this metadata.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(eval-when-compile
  (require 'dbus))

(cl-defun unpackaged/mpris-track (&amp;optional player)
  "Return the artist, album, and title of the track playing in MPRIS-supporting player.
Returns a string in format \"ARTIST - ALBUM: TITLE [PLAYER]\".  If no track is
playing, returns nil.  If more than one player is playing, uses
the first one found in DBus.

If PLAYER is non-nil, include the name of the player in the
output string."
  (require 'dbus)
  (when-let* ((mpris-services (--select (string-prefix-p "org.mpris.MediaPlayer2." it)
					(dbus-list-known-names :session)))
	      (playing-service (--first (string= "Playing"
						 (dbus-get-property :session it
								    "/org/mpris/MediaPlayer2"
								    "org.mpris.MediaPlayer2.Player"
								    "PlaybackStatus"))
					mpris-services))
	      (player-name (dbus-get-property :session playing-service
					      "/org/mpris/MediaPlayer2"
					      "org.mpris.MediaPlayer2"
					      "Identity"))
	      (metadata (dbus-get-property :session playing-service
					   "/org/mpris/MediaPlayer2"
					   "org.mpris.MediaPlayer2.Player"
					   "Metadata")))
    ;; `-let' makes it easy to get the actual strings out of the nested lists of lists of strings.
    (-let (((&amp;alist "xesam:artist" ((artists))
		    "xesam:album" ((album))
		    "xesam:title" ((title)))
	    metadata))
      (format "%s - %s: %s%s" (s-join ", " artists) album title
	      (if player
		  (format " [%s]" player-name)
		"")))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-Org" class="outline-2">
<h2 id="Org">Org&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Org">Org</span></span></h2>
<div class="outline-text-2" id="text-Org">
<p>
Code for <a href="https://orgmode.org/">Org Mode</a>.
</p>
</div>


<div id="outline-container-Agenda" class="outline-3">
<h3 id="Agenda">Agenda&#xa0;&#xa0;&#xa0;<span class="tag"><span class="agenda">agenda</span></span></h3>
<div class="outline-text-3" id="text-Agenda">
</div>
<div id="outline-container-Agenda%20for%20subtree%20or%20region" class="outline-4">
<h4 id="Agenda%20for%20subtree%20or%20region">Agenda for subtree or region</h4>
<div class="outline-text-4" id="text-Agenda%20for%20subtree%20or%20region">
<p>
Display an agenda view for the current subtree or region.  With prefix, display only <code>TODO</code>-keyword items.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defvar org-agenda-overriding-header)
(defvar org-agenda-sorting-strategy)
(defvar org-agenda-restrict)
(defvar org-agenda-restrict-begin)
(defvar org-agenda-restrict-end)

;;;###autoload
(defun unpackaged/org-agenda-current-subtree-or-region (only-todos)
  "Display an agenda view for the current subtree or region.
 With prefix, display only TODO-keyword items."
  (interactive "P")
  (let ((starting-point (point))
	header)
    (with-current-buffer (or (buffer-base-buffer (current-buffer))
			     (current-buffer))
      (if (use-region-p)
	  (progn
	    (setq header "Region")
	    (put 'org-agenda-files 'org-restrict (list (buffer-file-name (current-buffer))))
	    (setq org-agenda-restrict (current-buffer))
	    (move-marker org-agenda-restrict-begin (region-beginning))
	    (move-marker org-agenda-restrict-end
			 (save-excursion
			   ;; If point is at beginning of line, include
			   ;; heading on that line by moving forward 1.
			   (goto-char (1+ (region-end)))
			   (org-end-of-subtree))))
	;; No region; restrict to subtree.
	(save-excursion
	  (save-restriction
	    ;; In case the command was called from an indirect buffer, set point
	    ;; in the base buffer to the same position while setting restriction.
	    (widen)
	    (goto-char starting-point)
	    (setq header "Subtree")
	    (org-agenda-set-restriction-lock))))
      ;; NOTE: Unlike other agenda commands, binding `org-agenda-sorting-strategy'
      ;; around `org-search-view' seems to have no effect.
      (let ((org-agenda-sorting-strategy '(priority-down timestamp-up))
	    (org-agenda-overriding-header header))
	(org-search-view (if only-todos t nil) "*"))
      (org-agenda-remove-restriction-lock t)
      (message nil))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Agenda%20for%20outline%20path" class="outline-4">
<h4 id="Agenda%20for%20outline%20path">Agenda for outline path</h4>
<div class="outline-text-4" id="text-Agenda%20for%20outline%20path">
<p>
Show an agenda restricted to subtree at <code>OUTLINE-PATH</code>.  <code>FILE</code> may be a filename to search in, or nil to look in the current buffer.  If <code>ONLY-TODOS</code> is non-nil, show only to-do items. <code>OUTLINE-PATH</code> is a list of strings which are outline headings.  See function <code>org-find-olp</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/org-agenda-olp (outline-path &amp;optional file only-todos)
  "Show an agenda restricted to subtree at OUTLINE-PATH.
FILE may be a filename to search in, or nil to look in the
current buffer.  If ONLY-TODOS is non-nil, show only to-do
items. OUTLINE-PATH is a list of strings which are outline
headings.  See function `org-find-olp'."
  (when file
    (push file outline-path))
  (let ((marker (org-find-olp outline-path (not file))))
    (with-current-buffer (marker-buffer marker)
      (org-with-wide-buffer
       (goto-char marker)
       (unpackaged/org-agenda-current-subtree-or-region only-todos)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Agenda%20previews" class="outline-4">
<h4 id="Agenda%20previews">Agenda previews</h4>
<div class="outline-text-4" id="text-Agenda%20previews">
<p>
<i>Before:</i>
</p>

<p>

</p>

<p>
<i>After:</i>
</p>

<p>

</p>

<p>
<b>Requires:</b>
</p>
<ul class="org-ul">
<li><a href="https://github.com/ShingoFukuyama/ov.el">ov</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-elisp">(defface unpackaged/org-agenda-preview
  '((t (:background "black")))
  "Face for Org Agenda previews."
  :group 'org)

;;;###autoload
(defun unpackaged/org-agenda-toggle-preview ()
  "Toggle overlay of current item in agenda."
  (interactive)
  (if-let* ((overlay (ov-in 'unpackaged/org-agenda-preview t (line-end-position) (line-end-position))))
      ;; Hide existing preview
      (ov-reset overlay)
    ;; Show preview
    (let* ((entry-contents (--&gt; (org-agenda-with-point-at-orig-entry
				 nil (buffer-substring (save-excursion
							 (unpackaged/org-forward-to-entry-content t)
							 (point))
						       (org-entry-end-position)))
				s-trim
				(concat "\n" it "\n"))))
      (add-face-text-property 0 (length entry-contents)
			      'unpackaged/org-agenda-preview nil entry-contents)
      (ov (line-end-position) (line-end-position)
	  'unpackaged/org-agenda-preview t
	  'before-string entry-contents))))

(defun unpackaged/org-forward-to-entry-content (&amp;optional unsafe)
  "Skip headline, planning line, and all drawers in current entry.
If UNSAFE is non-nil, assume point is on headline."
  (unless unsafe
    ;; To improve performance in loops (e.g. with `org-map-entries')
    (org-back-to-heading))
  (cl-loop for element = (org-element-at-point)
	   for pos = (pcase element
		       (`(headline . ,_) (org-element-property :contents-begin element))
		       (`(,(or 'planning 'property-drawer 'drawer) . ,_) (org-element-property :end element)))
	   while pos
	   do (goto-char pos)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Miscellaneous" class="outline-3">
<h3 id="Miscellaneous">Miscellaneous</h3>
<div class="outline-text-3" id="text-Miscellaneous">
</div>
<div id="outline-container-Convert%20Elisp%20to%20Org%20format" class="outline-4">
<h4 id="Convert%20Elisp%20to%20Org%20format">Convert Elisp to Org format&#xa0;&#xa0;&#xa0;<span class="tag"><span class="meta">meta</span></span></h4>
<div class="outline-text-4" id="text-Convert%20Elisp%20to%20Org%20format">
<p>
These functions convert Emacs Lisp code and docstrings to Org-formatted text, helpful for inserting into readme files (like this one).
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(cl-defun unpackaged/package-org-docs (&amp;optional (package (unpackaged/buffer-provides)))
  "Return documentation about PACKAGE as an Org string.
Interactively, place on kill ring."
  (interactive)
  (let* ((commands (--map (cons it (if (documentation it)
				       (unpackaged/docstring-to-org (documentation it))
				     "Undocumented."))
			  (-sort (-on #'string&lt; #'symbol-name)
				 (unpackaged/package-commands package))))
	 (functions (seq-difference (--map (cons it (if (documentation it)
							(unpackaged/docstring-to-org (documentation it))
						      "Undocumented."))
					   (-sort (-on #'string&lt; #'symbol-name)
						  (unpackaged/package-functions package)))
				    commands))
	 (commands-string (when commands
			    (-&gt;&gt; commands
				 (--map (format "+  ~%s%s~ :: %s"
						(car it)
						(--when-let (documentation (car it))
						  (concat " (" (unpackaged/docstring-function-args it) ")"))
						(cdr it)))
				 (s-join "\n")
				 (format "* Commands\n\n%s"))))
	 (functions-string (when functions
			     (-&gt;&gt; functions
				  (--map (format "+  ~%s%s~ :: %s"
						 (car it)
						 (--when-let (documentation (car it))
						   (concat " (" (unpackaged/docstring-function-args it) ")"))
						 (cdr it)))
				  (s-join "\n")
				  (format "* Functions\n\n%s"))))
	 (string (s-join "\n\n" (list commands-string functions-string))))
    (if (called-interactively-p 'any)
	(progn
	  (kill-new string)
	  (message "Documentation stored in kill ring"))
      string)))

(cl-defun unpackaged/package-commands (&amp;optional (package (unpackaged/buffer-provides)))
  "Return list of command symbols in PACKAGE, or current buffer's package."
  (let* ((functions (unpackaged/package-functions package)))
    (-select #'commandp functions)))

(cl-defun unpackaged/package-functions (&amp;optional (package (unpackaged/buffer-provides)))
  "Return list of functions defined in PACKAGE, or current buffer's package."
  (let* ((prefix (symbol-name package))
	 (symbols))
    (mapatoms (lambda (symbol)
		(when (string-prefix-p prefix (symbol-name symbol))
		  (push symbol symbols))))
    (-&gt;&gt; symbols
	 (-select #'fboundp)
	 (--select (not (string-suffix-p "--cmacro" (symbol-name it)))))))

(cl-defun unpackaged/buffer-provides (&amp;optional (buffer (current-buffer)))
  "Return symbol that Emacs package in BUFFER provides."
  ;; I couldn't find an existing function that does this, but this is simple enough.
  (with-current-buffer buffer
    (save-excursion
      (goto-char (point-max))
      (re-search-backward (rx bol "(provide '" (group (1+ (not (any ")")))) ")"))
      (intern (match-string 1)))))

;;;###autoload
(defun unpackaged/elisp-to-org ()
  "Convert elisp code in region to Org syntax and put in kill-ring.
Extracts and converts docstring to Org text, and places code in
source block."
  (interactive)
  (let* ((raw (-&gt;&gt; (buffer-substring (region-beginning) (region-end))
		   (replace-regexp-in-string (rx bol) "  ")
		   (replace-regexp-in-string (rx bol (1+ blank) eol) "")))
	 (sexp (read raw))
	 (docstring (--when-let (-first #'stringp sexp)
		      (unpackaged/docstring-to-org it))))
    (kill-new (concat docstring (when docstring "\n\n")
		      "#+BEGIN_SRC elisp" "\n"
		      raw "\n"
		      "#+END_SRC"))))

;;;###autoload
(defun unpackaged/docstring-to-org (docstring)
  "Return DOCSTRING as formatted Org text.

Interactively, get text from region, and kill formatted Org text
to kill-ring."
  (interactive (list (buffer-substring (region-beginning) (region-end))))
  (cl-macrolet ((string-buffer--&gt; (string &amp;rest forms)
				  `(with-temp-buffer
				     (insert ,string)
				     ,@(cl-loop for form in forms
						collect `(goto-char (point-min))
						collect form)
				     (buffer-string))))
    (--&gt; (string-buffer--&gt; docstring
			   (progn
			     ;; Remove end-of-string function argument list
			     (goto-char (point-max))
			     (when (re-search-backward (rx "\n\n" "(fn " (group (1+ not-newline)) ")" eos) nil t)
			       (replace-match "" t t)))
			   (unpackaged/caps-to-code (point-min) (point-max))
			   (unpackaged/symbol-quotes-to-org-code (point-min) (point-max))
			   (unfill-region (point-min) (point-max))
			   (while (re-search-forward (rx bol (group (1+ blank))) nil t)
			     (replace-match "" t t nil 1))
			   (while (re-search-forward "\n" nil t)
			     (replace-match "\n   " t t))
			   (when (looking-at "\"")
			     (delete-char 1))
			   (when (progn
				   (goto-char (point-max))
				   (looking-back "\"" nil))
			     (delete-char -1))
			   (while (re-search-forward (rx bol (group (&gt;= 2 " ")) (group (1+ (not space)) (1+ not-newline))) nil t)
			     ;; Indented code samples, by two or more spaces
			     (replace-match (concat (match-string 1) "~" (match-string 2) "~"))))
	 (s-trim it)
	 (if (called-interactively-p 'interactive)
	     (progn
	       (message it)
	       (kill-new it))
	   it))))

(defun unpackaged/docstring-function-args (docstring)
  "Return function args parsed from DOCSTRING.
DOCSTRING should be like one returned by function
`documentation', which typically has function arguments on the
last line."
  (when (string-match (rx "\n\n" "(fn " (group (1+ not-newline)) ")" eos) docstring)
    (match-string 1 docstring)))

;;;###autoload
(defun unpackaged/caps-to-code (beg end)
  "Convert all-caps words in region to Org code emphasis."
  (interactive "r")
  (let ((case-fold-search nil))
    (save-excursion
      (save-restriction
	(narrow-to-region beg end)
	(goto-char (point-min))
	(while (re-search-forward (rx (or space bol)
				      (group (1+ (or upper "-")))
				      (or space eol (char punct)))
				  nil t)
	  (setf (buffer-substring (match-beginning 1) (match-end 1))
		(concat "~" (match-string 1) "~"))
	  (goto-char (match-end 0)))))))

;;;###autoload
(defun unpackaged/symbol-quotes-to-org-code (beg end)
  "Change Emacs `symbol' quotes to Org =symbol= quotes in region."
  (interactive "r")
  (save-excursion
    (save-restriction
      (goto-char beg)
      (narrow-to-region beg end)
      (while (re-search-forward (rx (or "`" "‘") (group (1+ (or word (syntax symbol)))) (or "’" "'")) nil t)
	(replace-match (concat "~" (match-string 1) "~") t)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Attachments" class="outline-3">
<h3 id="Attachments">Attachments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="attachments">attachments</span></span></h3>
<div class="outline-text-3" id="text-Attachments">
</div>
<div id="outline-container-Download%20and%20attach%20remote%20files" class="outline-4">
<h4 id="Download%20and%20attach%20remote%20files">Download and attach remote files</h4>
<div class="outline-text-4" id="text-Download%20and%20attach%20remote%20files">
<p>
Download file at <code>URL</code> and attach with <code>org-attach</code>.  Interactively, look for <code>URL</code> at point, in X clipboard, and in kill-ring, prompting if not found.  With prefix, prompt for <code>URL</code>.
</p>

<p>
<b>Requires:</b>
</p>
<ul class="org-ul">
<li><a href="https://github.com/alphapapa/org-web-tools">org-web-tools</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/org-attach-download (url)
  "Download file at URL and attach with `org-attach'.
Interactively, look for URL at point, in X clipboard, and in
kill-ring, prompting if not found.  With prefix, prompt for URL."
  (interactive (list (if current-prefix-arg
			 (read-string "URL: ")
		       (or (org-element-property :raw-link (org-element-context))
			   (org-web-tools--get-first-url)
			   (read-string "URL: ")))))
  (when (yes-or-no-p (concat "Attach file at URL: " url))
    (let* ((temp-dir (make-temp-file "org-attach-download-" 'dir))
	   (basename (file-name-nondirectory (directory-file-name url)))
	   (local-path (expand-file-name basename temp-dir))
	   size)
      (unwind-protect
	  (progn
	    (url-copy-file url local-path 'ok-if-exists 'keep-time)
	    (setq size (file-size-human-readable
			(file-attribute-size
			 (file-attributes local-path))))
	    (org-attach-attach local-path nil 'mv)
	    (message "Attached %s (%s)" url size))
	(delete-directory temp-dir)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Exporting" class="outline-3">
<h3 id="Exporting">Exporting</h3>
<div class="outline-text-3" id="text-Exporting">
</div>
<div id="outline-container-Export%20to%20HTML%20with%20%2Fuseful%2F%20anchors" class="outline-4">
<h4 id="Export%20to%20HTML%20with%20%2Fuseful%2F%20anchors">Export to HTML with <i>useful</i> anchors</h4>
<div class="outline-text-4" id="text-Export%20to%20HTML%20with%20%2Fuseful%2F%20anchors">
<p>
This minor mode causes Org HTML export to use heading titles for HTML IDs and anchors.  For example, instead of:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;li&gt;&lt;a href="#org11177f0"&gt;Usage...
&lt;li&gt;&lt;a href="#orge2a172e"&gt;Faces, fonts...
</pre>
</div>

<p>
You get:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;li&gt;&lt;a href="#Usage"&gt;Usage...
&lt;li&gt;&lt;a href="#Faces%2C%20fonts"&gt;Faces, fonts...
</pre>
</div>

<p>
So links to sections of the exported HTML will remain useful, rather than being different, random numbers every time the document is exported.  If an anchor is not unique, its ancestor headings are prepended one-at-a-time until unique, and when no more ancestors remain, a number is appended and incremented until unique.  For an example of how this works out in practice, see the links made to headings <a href="https://alphapapa.github.io/emacs-package-dev-handbook/">here</a>, of which there are many having the same name (e.g. <code>Tools</code>, <code>Libraries</code>, etc).
</p>

<p>
Note that this is somewhat of a hack, and it probably breaks some feature deep inside Org Export.  But it seems to work, and it solves the problem!
</p>

<div class="org-src-container">
<pre class="src src-elisp">(eval-when-compile
  (require 'easy-mmode)
  (require 'ox))

(use-package ox
  :config
  (define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
    "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
    :global t
    (if unpackaged/org-export-html-with-useful-ids-mode
	(advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
      (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))

  (defun unpackaged/org-export-get-reference (datum info)
    "Like `org-export-get-reference', except uses heading titles instead of random numbers."
    (let ((cache (plist-get info :internal-references)))
      (or (car (rassq datum cache))
	  (let* ((crossrefs (plist-get info :crossrefs))
		 (cells (org-export-search-cells datum))
		 ;; Preserve any pre-existing association between
		 ;; a search cell and a reference, i.e., when some
		 ;; previously published document referenced a location
		 ;; within current file (see
		 ;; `org-publish-resolve-external-link').
		 ;;
		 ;; However, there is no guarantee that search cells are
		 ;; unique, e.g., there might be duplicate custom ID or
		 ;; two headings with the same title in the file.
		 ;;
		 ;; As a consequence, before re-using any reference to
		 ;; an element or object, we check that it doesn't refer
		 ;; to a previous element or object.
		 (new (or (cl-some
			   (lambda (cell)
			     (let ((stored (cdr (assoc cell crossrefs))))
			       (when stored
				 (let ((old (org-export-format-reference stored)))
				   (and (not (assoc old cache)) stored)))))
			   cells)
			  (when (org-element-property :raw-value datum)
			    ;; Heading with a title
			    (unpackaged/org-export-new-title-reference datum cache))
			  ;; NOTE: This probably breaks some Org Export
			  ;; feature, but if it does what I need, fine.
			  (org-export-format-reference
			   (org-export-new-reference cache))))
		 (reference-string new))
	    ;; Cache contains both data already associated to
	    ;; a reference and in-use internal references, so as to make
	    ;; unique references.
	    (dolist (cell cells) (push (cons cell new) cache))
	    ;; Retain a direct association between reference string and
	    ;; DATUM since (1) not every object or element can be given
	    ;; a search cell (2) it permits quick lookup.
	    (push (cons reference-string datum) cache)
	    (plist-put info :internal-references cache)
	    reference-string))))

  (defun unpackaged/org-export-new-title-reference (datum cache)
    "Return new reference for DATUM that is unique in CACHE."
    (cl-macrolet ((inc-suffixf (place)
			       `(progn
				  (string-match (rx bos
						    (minimal-match (group (1+ anything)))
						    (optional "--" (group (1+ digit)))
						    eos)
						,place)
				  ;; HACK: `s1' instead of a gensym.
				  (-let* (((s1 suffix) (list (match-string 1 ,place)
							     (match-string 2 ,place)))
					  (suffix (if suffix
						      (string-to-number suffix)
						    0)))
				    (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
      (let* ((title (org-element-property :raw-value datum))
	     (ref (url-hexify-string (substring-no-properties title)))
	     (parent (org-element-property :parent datum)))
	(while (--any (equal ref (car it))
		      cache)
	  ;; Title not unique: make it so.
	  (if parent
	      ;; Append ancestor title.
	      (setf title (concat (org-element-property :raw-value parent)
				  "--" title)
		    ref (url-hexify-string (substring-no-properties title))
		    parent (org-element-property :parent parent))
	    ;; No more ancestors: add and increment a number.
	    (inc-suffixf ref)))
	ref))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Editing" class="outline-3">
<h3 id="Editing">Editing</h3>
<div class="outline-text-3" id="text-Editing">
</div>
<div id="outline-container-Ensure%20blank%20lines%20between%20headings%20and%20before%20contents" class="outline-4">
<h4 id="Ensure%20blank%20lines%20between%20headings%20and%20before%20contents">Ensure blank lines between headings and before contents</h4>
<div class="outline-text-4" id="text-Ensure%20blank%20lines%20between%20headings%20and%20before%20contents">
<p>
Ensure that blank lines exist between headings and between headings and their contents.  With prefix, operate on whole buffer.  Ensures that blank lines exist after each headings's drawers.
</p>

<p>
For those who prefer to maintain blank lines between headings, this makes it easy to automatically add them where necessary, to a subtree or the whole buffer.  It also adds blank lines after drawers.  Works well with <a href="#~org-return-dwim~"><code>org-return-dwim</code></a>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/org-fix-blank-lines (&amp;optional prefix)
  "Ensure that blank lines exist between headings and between headings and their contents.
With prefix, operate on whole buffer. Ensures that blank lines
exist after each headings's drawers."
  (interactive "P")
  (org-map-entries (lambda ()
		     (org-with-wide-buffer
		      ;; `org-map-entries' narrows the buffer, which prevents us from seeing
		      ;; newlines before the current heading, so we do this part widened.
		      (while (not (looking-back "\n\n" nil))
			;; Insert blank lines before heading.
			(insert "\n")))
		     (let ((end (org-entry-end-position)))
		       ;; Insert blank lines before entry content
		       (forward-line)
		       (while (and (org-at-planning-p)
				   (&lt; (point) (point-max)))
			 ;; Skip planning lines
			 (forward-line))
		       (while (re-search-forward org-drawer-regexp end t)
			 ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
			 ;; for some reason it doesn't work correctly when operating on hidden text.
			 ;; This works, taken from `org-agenda-get-some-entry-text'.
			 (re-search-forward "^[ \t]*:END:.*\n?" end t)
			 (goto-char (match-end 0)))
		       (unless (or (= (point) (point-max))
				   (org-at-heading-p)
				   (looking-at-p "\n"))
			 (insert "\n"))))
		   t (if prefix
			 nil
		       'tree)))
</pre>
</div>
</div>
</div>

<div id="outline-container-Surround%20region%20with%20emphasis%20or%20syntax%20characters" class="outline-4">
<h4 id="Surround%20region%20with%20emphasis%20or%20syntax%20characters">Surround region with emphasis or syntax characters</h4>
<div class="outline-text-4" id="text-Surround%20region%20with%20emphasis%20or%20syntax%20characters">
<p>
Define and bind interactive commands for each of <code>KEYS</code> that surround the region or insert text.  Commands are bound in <code>org-mode-map</code> to each of <code>KEYS</code>.  If the region is active, commands surround it with the key character, otherwise call <code>org-self-insert-command</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defmacro unpackaged/def-org-maybe-surround (&amp;rest keys)
  "Define and bind interactive commands for each of KEYS that surround the region or insert text.
Commands are bound in `org-mode-map' to each of KEYS.  If the
region is active, commands surround it with the key character,
otherwise call `org-self-insert-command'."
  `(progn
     ,@(cl-loop for key in keys
		for name = (intern (concat "unpackaged/org-maybe-surround-" key))
		for docstring = (format "If region is active, surround it with \"%s\", otherwise call `org-self-insert-command'." key)
		collect `(defun ,name ()
			   ,docstring
			   (interactive)
			   (if (region-active-p)
			       (let ((beg (region-beginning))
				     (end (region-end)))
				 (save-excursion
				   (goto-char end)
				   (insert ,key)
				   (goto-char beg)
				   (insert ,key)))
			     (call-interactively #'org-self-insert-command)))
		collect `(define-key org-mode-map (kbd ,key) #',name))))
</pre>
</div>

<p>
Used like:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(unpackaged/def-org-maybe-surround "~" "=" "*" "/" "+")
</pre>
</div>
</div>
</div>

<div id="outline-container-Read-only%20trees" class="outline-4">
<h4 id="Read-only%20trees">Read-only trees</h4>
<div class="outline-text-4" id="text-Read-only%20trees">
<p>
This code applies the <code>read-only</code> text-property to trees tagged <code>read_only</code>, preventing them from being modified accidentally.  (Note: If read-only headings appear in an Agenda buffer, it can cause slightly unusual behavior.  Usually this is not an issue.)  This was originally inspired by John Kitchin's <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/09/13/Make-some-org-sections-read-only/">blog article</a> and later <a href="https://www.reddit.com/r/emacs/comments/92k7n1/guide_to_profiling_and_optimizing_an_orgrelated/">rewritten</a> in a faster version.
</p>

<p>
To use, load these functions, and then add to this hook to automatically mark read-only sections when an Org file is loaded:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(add-hook 'org-mode-hook 'unpackaged/org-mark-read-only)
</pre>
</div>

<p>
The functions may also be called interactively as needed.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/org-next-heading-tagged (tag)
  "Move to beginning of next heading tagged with TAG and return point, or return nil if none found."
  (when (re-search-forward (rx-to-string `(seq bol (1+ "*") (1+ blank) (optional (1+ not-newline) (1+ blank))
					       ;; Beginning of tags
					       ":"
					       ;; Possible other tags
					       (0+ (seq (1+ (not (any ":" blank))) ":") )
					       ;; The tag that matters
					       ,tag ":"))
			   nil 'noerror)
    (goto-char (match-beginning 0))))

  ;;;###autoload
(defun unpackaged/org-mark-read-only ()
  "Mark all entries in the buffer tagged \"read_only\" with read-only text properties."
  (interactive)
  (org-with-wide-buffer
   (goto-char (point-min))
   (while (unpackaged/org-next-heading-tagged "read_only")
     (add-text-properties (point) (org-end-of-subtree t)
			  '(read-only t)))))

(defun unpackaged/org-remove-read-only ()
  "Remove read-only text properties from Org entries tagged \"read_only\" in current buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (org-with-wide-buffer
     (goto-char (point-min))
     (while (unpackaged/org-next-heading-tagged "read_only")
       (remove-text-properties (point) (org-end-of-subtree t)
			       '(read-only t))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-~org-return-dwim~" class="outline-4">
<h4 id="~org-return-dwim~"><code>org-return-dwim</code></h4>
<div class="outline-text-4" id="text-~org-return-dwim~">
<p>
A helpful replacement for <code>org-return</code>.  With prefix, call <code>org-return</code>.
</p>

<p>
On headings, move point to position after entry content.  In lists, insert a new item or end the list, with checkbox if appropriate.  In tables, insert a new row or end the table.
</p>

<p>
Inspired by <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/">John Kitchin</a>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  ;; MAYBE: Use `org-element-lineage'.
  (when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
	(unpackaged/org-element-descendant-of type parent))))

;;;###autoload
(defun unpackaged/org-return-dwim (&amp;optional default)
  "A helpful replacement for `org-return'.  With prefix, call `org-return'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ;; ((eq 'link (car (org-element-context)))
     ;;  ;; Link: Open it.
     ;;  (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
	(goto-char (org-entry-end-position))
	(cond ((and (org-at-heading-p)
		    (= heading-start (org-entry-beginning-position)))
	       ;; Entry ends on its heading; add newline after
	       (end-of-line)
	       (insert "\n\n"))
	      (t
	       ;; Entry ends after its heading; back up
	       (forward-line -1)
	       (end-of-line)
	       (when (org-at-heading-p)
		 ;; At the same heading
		 (forward-line)
		 (insert "\n")
		 (forward-line -1))
	       ;; FIXME: looking-back is supposed to be called with more arguments.
	       (while (not (looking-back (rx (repeat 3 (seq (optional blank) "\n")))))
		 (insert "\n"))
	       (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
	(if (or (eq 'plain-list (car context))  ; First item in list
		(and (eq 'item (car context))
		     (not (eq (org-element-property :contents-begin context)
			      (org-element-property :contents-end context))))
		(unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
	    ;; Non-empty item: Add new item.
	    (org-insert-item)
	  ;; Empty item: Close the list.
	  ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
	  (delete-region (line-beginning-position) (line-end-position))
	  (insert "\n"))))

     ((when (fboundp 'org-inlinetask-in-task-p)
	(org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return))

     ((org-at-table-p)
      (cond ((save-excursion
	       (beginning-of-line)
	       ;; See `org-table-next-field'.
	       (cl-loop with end = (line-end-position)
			for cell = (org-element-table-cell-parser)
			always (equal (org-element-property :contents-begin cell)
				      (org-element-property :contents-end cell))
			while (re-search-forward "|" end t)))
	     ;; Empty row: end the table.
	     (delete-region (line-beginning-position) (line-end-position))
	     (org-return))
	    (t
	     ;; Non-empty row: call `org-return'.
	     (org-return))))
     (t
      ;; All other cases: call `org-return'.
      (org-return)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Display" class="outline-3">
<h3 id="Display">Display</h3>
<div class="outline-text-3" id="text-Display">
</div>
<div id="outline-container-Force%20monospace%20face%20in%20tables" class="outline-4">
<h4 id="Force%20monospace%20face%20in%20tables">Force monospace face in tables</h4>
<div class="outline-text-4" id="text-Force%20monospace%20face%20in%20tables">
<p>
If you use variable-pitch (a.k.a. "proportional") fonts in Org buffers (e.g. using <a href="https://github.com/cadadr/elisp/blob/devel/org-variable-pitch.el">org-variable-pitch</a>), you probably use monospace fonts for Org tables, so they align properly.  However, other elements in a table (such as links, or perhaps timestamps) may still use variable-pitch fonts, which breaks alignment.  This code fixes that by forcibly applying the <code>org-table</code> face family to entire Org tables (which are detected by finding existing text with the <code>org-table</code> face, which makes use of Org's built-in fontification).
</p>

<p>
To use, activate <code>unpackaged/org-table-face-mode</code>.  You may want to add it to <code>org-mode-hook</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(define-minor-mode unpackaged/org-table-face-mode
  "Apply `org-table' face family to all text in Org tables.
Useful for forcibly applying the face to portions of table data
that might have a different face, which could affect alignment."
  :global nil
  (let ((keywords '((unpackaged/org-table-face-matcher 0 'org-table))))
    (if unpackaged/org-table-face-mode
	(font-lock-add-keywords nil keywords 'append)
      (font-lock-remove-keywords nil keywords))
    (font-lock-flush)))

(cl-defun unpackaged/org-table-face-matcher
    (limit &amp;optional (face `(:family ,(face-attribute 'org-table :family))))
  "Apply FACE to entire Org tables.
A `font-lock-keywords' function that searches up to LIMIT."
  (cl-flet* ((find-face (face &amp;optional limit not)
			;; Return next position up to LIMIT that has FACE, or doesn't if NOT.
			(cl-loop with prev-pos
				 with pos = (point)
				 while (not (eobp))
				 do (setf pos (next-single-property-change pos 'face nil limit))
				 while (and pos (not (equal pos prev-pos)))
				 for face-at = (get-text-property pos 'face)
				 for face-matches-p = (or (eq face-at face)
							  (when (listp face-at)
							    (member face face-at)))
				 when (or (and not (not face-matches-p))
					  face-matches-p)
				 return pos
				 do (setf prev-pos pos)))
	     (apply-face-from (pos face)
			      (unless (eobp)
				(let* ((property-at-start (get-text-property pos 'face))
				       (table-face-start (if (or (eq property-at-start 'org-table)
								 (when (listp property-at-start)
								   (member 'org-table property-at-start)))
							     (point)
							   (find-face 'org-table limit)))
				       table-face-end)
				  (when table-face-start
				    (goto-char table-face-start)
				    (setf table-face-end (line-end-position))
				    (add-face-text-property table-face-start table-face-end face)
				    (goto-char table-face-end))))))
    (cl-loop with applied-p
	     for applied = (apply-face-from (point) face)
	     when applied
	     do (setf applied-p t)
	     while applied
	     finally return applied-p)))
</pre>
</div>
</div>
</div>

<div id="outline-container-Outline%20number%20overlays" class="outline-4">
<h4 id="Outline%20number%20overlays">Outline number overlays</h4>
<div class="outline-text-4" id="text-Outline%20number%20overlays">
<p>
This command displays outline numbers (like the ones used when exporting) in a buffer as overlays at the beginning of each heading.  It doesn't update automatically, so it must be called when the outline structure changes.
</p>

<p>

</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/org-outline-numbers (&amp;optional remove-p)
  "Add outline number overlays to the current buffer.
When REMOVE-P is non-nil (interactively, with prefix), remove
them.  Overlays are not automatically updated when the outline
structure changes."
  ;; NOTE: This does not necessarily play nicely with org-indent-mode
  ;; or org-bullets, but it probably wouldn't be too hard to fix that.
  (interactive (list current-prefix-arg))
  (cl-labels ((heading-number ()
	       (or (when-let ((num (previous-sibling-number)))
		     (1+ num))
		   1))
	      (previous-sibling-number ()
	       (save-excursion
		 (let ((pos (point)))
		   (org-backward-heading-same-level 1)
		   (when (/= pos (point))
		     (heading-number)))))
	      (number-list ()
	       (let ((ancestor-numbers (save-excursion
					 (cl-loop while (org-up-heading-safe)
						  collect (heading-number)))))
		 (nreverse (cons (heading-number) ancestor-numbers))))
	      (add-overlay ()
	       (let* ((ov-length (org-current-level))
		      (ov (make-overlay (point) (+ (point) ov-length)))
		      (ov-string (concat (mapconcat #'number-to-string (number-list) ".")
					 ".")))
		 (overlay-put ov 'org-outline-numbers t)
		 (overlay-put ov 'display ov-string))))
    (remove-overlays nil nil 'org-outline-numbers t)
    (unless remove-p
      (org-with-wide-buffer
       (goto-char (point-min))
       (when (org-before-first-heading-p)
	 (outline-next-heading))
       (cl-loop do (add-overlay)
		while (outline-next-heading))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Refiling" class="outline-3">
<h3 id="Refiling">Refiling</h3>
<div class="outline-text-3" id="text-Refiling">
</div>
<div id="outline-container-Refile%20to%20datetree%20file%20using%20earliest%2Flatest%20timestamp%20in%20entry" class="outline-4">
<h4 id="Refile%20to%20datetree%20file%20using%20earliest%2Flatest%20timestamp%20in%20entry">Refile to datetree file using earliest/latest timestamp in entry</h4>
<div class="outline-text-4" id="text-Refile%20to%20datetree%20file%20using%20earliest%2Flatest%20timestamp%20in%20entry">
<p>
Refile current entry to datetree using timestamp found in entry.  <code>WHICH</code> should be <code>earliest</code> or <code>latest</code>. If <code>SUBTREE</code>-P is non-nil, search whole subtree.
</p>

<p>
This is sort of like archiving to a datetree, but it uses either the earliest or latest timestamp found in the entry or subtree rather than the current date.  It's helpful if you have an entry with lots of timestamps or log entries, and you're done with it, and you want to file it in a datetree in a leaf matching either when you started working on the entry or when you finished, using the first or last timestamp found anywhere in the entry.
</p>

<p>
<i>Note:</i> If you can think of a more concise name for this command, please send it in!
</p>

<p>
<b>Requires:</b> <a href="https://github.com/alphapapa/ts.el">ts</a>
</p>

<div class="org-src-container">
<pre class="src src-elisp">(require 'org)

(require 'ts)

;;;###autoload
(defun unpackaged/org-refile-to-datetree-using-ts-in-entry (which-ts file &amp;optional subtree-p)
  "Refile current entry to datetree in FILE using timestamp found in entry.
WHICH should be `earliest' or `latest'. If SUBTREE-P is non-nil,
search whole subtree."
  (interactive (list (intern (completing-read "Which timestamp? " '(earliest latest)))
		     (read-file-name "File: " (concat org-directory "/") nil 'mustmatch nil
				     (lambda (filename)
				       (string-suffix-p ".org" filename)))
		     current-prefix-arg))
  (require 'ts)
  (let* ((sorter (pcase which-ts
		   ('earliest #'ts&lt;)
		   ('latest #'ts&gt;)))
	 (tss (unpackaged/org-timestamps-in-entry subtree-p))
	 (ts (car (sort tss sorter)))
	 (date (list (ts-month ts) (ts-day ts) (ts-year ts))))
    (unpackaged/org-refile-to-datetree file :date date)))

;;;###autoload
(defun unpackaged/org-timestamps-in-entry (&amp;optional subtree-p)
  "Return timestamp objects for all Org timestamps in entry.
 If SUBTREE-P is non-nil (interactively, with prefix), search
 whole subtree."
  (interactive (list current-prefix-arg))
  (save-excursion
    (let* ((beg (org-entry-beginning-position))
	   (end (if subtree-p
		    (org-end-of-subtree)
		  (org-entry-end-position))))
      (goto-char beg)
      (cl-loop while (re-search-forward org-tsr-regexp-both end t)
	       collect (ts-parse-org (match-string 0))))))

;;;###autoload
(cl-defun unpackaged/org-refile-to-datetree (file &amp;key (date (calendar-current-date)) entry)
  "Refile ENTRY or current node to entry for DATE in datetree in FILE.
DATE should be a list of (MONTH DAY YEAR) integers, e.g. as
returned by `calendar-current-date'."
  (interactive (list (read-file-name "File: " (concat org-directory "/") nil 'mustmatch nil
				     (lambda (filename)
				       (string-suffix-p ".org" filename)))))
  ;; If org-datetree isn't loaded, it will cut the tree but not file
  ;; it anywhere, losing data. I don't know why
  ;; org-datetree-file-entry-under is in a separate package, not
  ;; loaded with the rest of org-mode.
  (require 'org-datetree)
  (unless entry
    (org-cut-subtree))
  ;; Using a condition-case to be extra careful. In case the refile
  ;; fails in any way, put cut subtree back.
  (condition-case err
      (with-current-buffer (or (org-find-base-buffer-visiting file)
			       (find-file-noselect file))
	(org-datetree-file-entry-under (or entry (car kill-ring)) date)
	(save-buffer))
    (error (unless entry
	     (org-paste-subtree))
	   (message "Unable to refile! %s" err))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Sorting" class="outline-3">
<h3 id="Sorting">Sorting</h3>
<div class="outline-text-3" id="text-Sorting">
</div>
<div id="outline-container-Recursive%20sorting%20by%20multiple%20keys" class="outline-4">
<h4 id="Recursive%20sorting%20by%20multiple%20keys">Recursive sorting by multiple keys</h4>
<div class="outline-text-4" id="text-Recursive%20sorting%20by%20multiple%20keys">
<p>
Call <code>org-sort-entries</code> recursively on tree at point by <code>keys</code>.  <code>keys</code> is a list of characters passed as the <code>sorting-type</code> argument to <code>org-sort-entries</code>, which see.
</p>

<p>
Suitable for use in a <code>before-save-hook</code>, like:
</p>

<div class="org-src-container">
<pre class="src src-org"># Local Variables:
# before-save-hook: ((unpackaged/org-sort-recursive '(?a ?p ?o)))
# End:
</pre>
</div>

<p>
<b>NOTE:</b> This doesn't work yet.  Sorting gets undone while reading the sort keys.  This is so awkward.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/org-sort-recursive (keys)
  "Call `org-sort-entries' recursively on tree at point by KEYS.
KEYS is a list of characters passed as the SORTING-TYPE argument
to `org-sort-entries', which see."
  (interactive
   (list (let (keys)
	   (save-excursion
	     (cl-loop while (progn
			      ;; HACK: Call the sort function just to get the key, then undo its changes.
			      (cl-letf* ((old-fn (symbol-function 'read-char-exclusive))
					 ((symbol-function 'read-char-exclusive)
					  (lambda (&amp;rest args)
					    (car (push (apply #'funcall old-fn args) keys)))))
				;; Sort the first heading and save the sort key.
				(let ((modified-tick (buffer-modified-tick)))
				  (condition-case nil
				      (progn
					(with-local-quit
					  (org-sort-entries))
					(unless (equal modified-tick (buffer-modified-tick))
					  (undo-only)))
				    (user-error nil))))
			      t)))
	   (nreverse keys))))
  (cl-macrolet ((moves-p (form)
			 `(let ((pos-before (point)))
			    ,form
			    (/= pos-before (point)))))
    (cl-labels ((sort-this-tree
		 () (cl-loop do (when (children-p)
				  (save-excursion
				    (outline-next-heading)
				    (sort-this-tree))
				  (condition-case nil
				      (org-sort-entries nil key)
				    (user-error nil)))
			     while (moves-p (org-forward-heading-same-level 1))))
		(children-p (&amp;optional invisible)
			    ;; Return non-nil if entry at point has child headings.
			    ;; Only children are considered, not other descendants.
			    ;; Code from `org-cycle-internal-local'.
			    (save-excursion
			      (let ((level (funcall outline-level)))
				(outline-next-heading)
				(and (org-at-heading-p t)
				     (&gt; (funcall outline-level) level)))))
		(sort-by
		 (key) (save-excursion
			 (save-restriction
			   (widen)
			   (cond
			    ((org-before-first-heading-p)
			     ;; Sort whole buffer.  NOTE: This assumes the first
			     ;; heading is at level 1.
			     (org-sort-entries nil key)
			     (outline-next-heading)
			     (cl-loop do (sort-this-tree)
				      while (moves-p (org-forward-heading-same-level 1))))
			    ((org-at-heading-p)
			     ;; Sort this heading.
			     (sort-this-tree))
			    (t (user-error "Neither on a heading nor before first heading")))))))
      (mapc #'sort-by keys))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-Packages" class="outline-2">
<h2 id="Packages">Packages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="packages">packages</span></span></h2>
<div class="outline-text-2" id="text-Packages">
</div>
<div id="outline-container-Delete%20all%20installed%20versions%20of%20a%20package" class="outline-3">
<h3 id="Delete%20all%20installed%20versions%20of%20a%20package">Delete all installed versions of a package</h3>
<div class="outline-text-3" id="text-Delete%20all%20installed%20versions%20of%20a%20package">
<p>
Delete all versions of package named <code>NAME</code>.  <code>NAME</code> may be a string or symbol.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/package-delete-all-versions (name &amp;optional force)
  "Delete all versions of package named NAME.
NAME may be a string or symbol."
  ;; Copied from `package-delete'.
  (let* ((package-name (cl-typecase name
			 (string (intern name))
			 (symbol name)))
	 (user-packages-list (-&gt;&gt; package-alist
				  ;; Just to be safe, we ignore built-ins.
				  (-select (-not #'package-built-in-p))))
	 (matching-versions (--select (eql (car it) package-name) user-packages-list)))
    ;; Safety checks.
    (cl-loop for (symbol first-desc . rest) in matching-versions
	     do (progn
		  (unless force
		    (when-let* ((dependent (package--used-elsewhere-p first-desc)))
		      (error "Package `%s' depends on `%s'" (package-desc-name dependent) package-name)))
		  (unless (string-prefix-p (file-name-as-directory (expand-file-name package-user-dir))
					   (expand-file-name (package-desc-dir first-desc)))
		    (error "Package `%s' is a system package" symbol))))
    ;; Checks passed: delete packages.
    (cl-loop for (_symbol . descs) in matching-versions
	     do (--each descs
		  (package-delete it force)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Reload%20a%20package%27s%20features" class="outline-3">
<h3 id="Reload%20a%20package%27s%20features">Reload a package's features</h3>
<div class="outline-text-3" id="text-Reload%20a%20package%27s%20features">
<p>
Reload <code>PACKAGE</code>'s features.  If <code>ALLP</code> is non-nil (interactively, with prefix), load all of its features; otherwise only load ones that were already loaded.
</p>

<p>
This is useful to reload a package after upgrading it.  Since a package may provide multiple features, to reload it properly would require either restarting Emacs or manually unloading and reloading each loaded feature.  This automates that process.
</p>

<p>
Note that this unloads all of the package's symbols before reloading.  Any data stored in those symbols will be lost, so if the package would normally save that data, e.g. when a mode is deactivated or when Emacs exits, the user should do so before using this command.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/reload-package (package &amp;optional allp)
  "Reload PACKAGE's features.
If ALLP is non-nil (interactively, with prefix), load all of its
features; otherwise only load ones that were already loaded.

This is useful to reload a package after upgrading it.  Since a
package may provide multiple features, to reload it properly
would require either restarting Emacs or manually unloading and
reloading each loaded feature.  This automates that process.

Note that this unloads all of the package's symbols before
reloading.  Any data stored in those symbols will be lost, so if
the package would normally save that data, e.g. when a mode is
deactivated or when Emacs exits, the user should do so before
using this command."
  (interactive
   (list (intern (completing-read "Package: "
				  (mapcar #'car package-alist) nil t))
	 current-prefix-arg))
  ;; This finds features in the currently installed version of PACKAGE, so if
  ;; it provided other features in an older version, those are not unloaded.
  (when (yes-or-no-p (format "Unload all of %s's symbols and reload its features? " package))
    (let* ((package-name (symbol-name package))
	   (package-dir (file-name-directory
			 (locate-file package-name load-path (get-load-suffixes))))
	   (package-files (directory-files package-dir 'full (rx ".el" eos)))
	   (package-features
	    (cl-loop for file in package-files
		     when (with-temp-buffer
			    (insert-file-contents file)
			    (when (re-search-forward (rx bol "(provide" (1+ space)) nil t)
			      (goto-char (match-beginning 0))
			      (cadadr (read (current-buffer)))))
		     collect it)))
      (unless allp
	(setf package-features (seq-intersection package-features features)))
      (dolist (feature package-features)
	(ignore-errors
	  ;; Ignore error in case it's not loaded.
	  (unload-feature feature 'force)))
      (dolist (feature package-features)
	(require feature))
      (message "Reloaded: %s" (mapconcat #'symbol-name package-features " ")))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Upgrade%20a%20~quelpa-use-package~%20form%27s%20package" class="outline-3">
<h3 id="Upgrade%20a%20~quelpa-use-package~%20form%27s%20package">Upgrade a <code>quelpa-use-package</code> form's package</h3>
<div class="outline-text-3" id="text-Upgrade%20a%20~quelpa-use-package~%20form%27s%20package">
<p>
Eval the current <code>use-package</code> form with <code>quelpa-upgrade-p</code> true.  Delete the package first to remove obsolete versions.  When <code>RELOADP</code> is non-nil, reload the package's features after upgrade using <code>unpackaged/reload-package</code>; otherwise (interactively, with prefix), leave old features loaded.
</p>

<p>
This makes it easy to upgrade a package you install with <a href="https://framagit.org/steckerhalter/quelpa-use-package">quelpa-use-package</a> without having to add <code>:upgrade t</code> to the form, which would cause Quelpa to <i>always</i> upgrade the package every time Emacs loads.
</p>

<p>
<b>Requires:</b>
</p>

<ul class="org-ul">
<li></li>
</ul>

<div class="org-src-container">
<pre class="src src-elisp">(defvar quelpa-upgrade-p)

;;;###autoload
(cl-defun unpackaged/quelpa-use-package-upgrade (&amp;key (reloadp t))
  "Eval the current `use-package' form with `quelpa-upgrade-p' true.
Delete the package first to remove obsolete versions.  When
RELOADP is non-nil, reload the package's features after upgrade
using `unpackaged/reload-package'; otherwise (interactively, with
prefix), leave old features loaded."
  (interactive (list :reloadp (not current-prefix-arg)))
  (save-excursion
    (if (or (looking-at (rx "(use-package "))
	    (let ((limit (save-excursion
			   (or (re-search-backward (rx bol "("))
			       (point-min)))))
	      ;; Don't go past previous top-level form
	      (re-search-backward (rx "(use-package ") limit t)))
	(progn
	  (pcase-let* ((`(use-package ,package-name . ,rest) (read (current-buffer))))
	    (cl-assert package-name nil "Can't determine package name")
	    (cl-assert (memq :quelpa rest) nil "`:quelpa' form not found")
	    (unpackaged/package-delete-all-versions package-name 'force)
	    (let ((quelpa-upgrade-p t))
	      (call-interactively #'eval-defun))
	    (when reloadp
	      (unpackaged/reload-package package-name))))
      (user-error "Not in a `use-package' form"))))
</pre>
</div>
</div>
</div>

<div id="outline-container-Upgrade%20one%20package%20in%20the%20package%20menu" class="outline-3">
<h3 id="Upgrade%20one%20package%20in%20the%20package%20menu">Upgrade one package in the package menu</h3>
<div class="outline-text-3" id="text-Upgrade%20one%20package%20in%20the%20package%20menu">
<p>
Mark current package for upgrading (i.e. also mark obsolete version for deletion.)
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package package
  :bind (:map package-menu-mode-map
	      ("t" . #'unpackaged/package-menu-upgrade-package))
  :config
  ;; I think the `use-package' form takes care of autoloading here.
  (defun unpackaged/package-menu-upgrade-package ()
    "Mark current package for upgrading (i.e. also mark obsolete version for deletion.)"
    (interactive)
    (when-let ((upgrades (package-menu--find-upgrades))
	       (description (tabulated-list-get-id))
	       (name (package-desc-name description))
	       (upgradable (cdr (assq name upgrades))))
      ;; Package is upgradable
      (save-excursion
	(goto-char (point-min))
	(while (not (eobp))
	  (let* ((current-description (tabulated-list-get-id))
		 (current-name (package-desc-name current-description)))
	    (when (equal current-name name)
	      (cond ((equal description current-description)
		     (package-menu-mark-install)
		     (forward-line -1))
		    (t (package-menu-mark-delete)))))
	  (forward-line 1))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Programming" class="outline-2">
<h2 id="Programming">Programming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="programming">programming</span></span></h2>
<div class="outline-text-2" id="text-Programming">
</div>
<div id="outline-container-Flexibly%20fill%2Funfill%20paragraphs" class="outline-3">
<h3 id="Flexibly%20fill%2Funfill%20paragraphs">Flexibly fill/unfill paragraphs</h3>
<div class="outline-text-3" id="text-Flexibly%20fill%2Funfill%20paragraphs">
<p>
Fill paragraph, incrementing fill column to cause a change when repeated.  The global value of <code>fill-column</code> is not modified; it is only bound around calls to <code>fill-paragraph</code>.  When called for the first time in a sequence, unfill to the default <code>fill-column</code>.  When called repeatedly, increase <code>fill-column</code> until filling changes.  With one universal prefix, increase <code>fill-column</code> until the number of lines is reduced.  With two, unfill completely.
</p>

<p>

</p>

<div class="org-src-container">
<pre class="src src-elisp">(defvar unpackaged/flex-fill-paragraph-column nil
  "Last fill column used in command `unpackaged/flex-fill-paragraph'.")

;;;###autoload
(defun unpackaged/flex-fill-paragraph (&amp;optional fewer-lines unfill)
  "Fill paragraph, incrementing fill column to cause a change when repeated.
The global value of `fill-column' is not modified; it is only
bound around calls to `fill-paragraph'.

When called for the first time in a sequence, unfill to the
default `fill-column'.

When called repeatedly, increase `fill-column' until filling
changes.

With one universal prefix, increase `fill-column' until the
number of lines is reduced.  With two, unfill completely."
  (interactive "P")
  (let* ((fewer-lines (or fewer-lines (equal current-prefix-arg '(4))))
	 (unfill (or unfill (equal current-prefix-arg '(16))))
	 (fill-column
	  (cond (unfill (setf unpackaged/flex-fill-paragraph-column nil)
			most-positive-fixnum)
		(t (setf unpackaged/flex-fill-paragraph-column
			 (if (equal last-command this-command)
			     (or (unpackaged/flex-fill-paragraph--next-fill-column fewer-lines)
				 fill-column)
			   fill-column))))))
    (fill-paragraph)
    (message "Fill column: %s" fill-column)))

(defun unpackaged/flex-fill-paragraph--next-fill-column (&amp;optional fewer-lines)
  "Return next `fill-column' value.
If FEWER-LINES is non-nil, reduce the number of lines in the
buffer, otherwise just change the current paragraph."
  ;; This works well, but because of all the temp buffers, sometimes when called
  ;; in rapid succession, it can cause GC, which can be noticeable.  It would be
  ;; nice to avoid that.  Note that this has primarily been tested on
  ;; `emacs-lisp-mode'; hopefully it works well in other modes.
  (let* ((point (point))
	 (source-buffer (current-buffer))
	 (mode major-mode)
	 (fill-column (or unpackaged/flex-fill-paragraph-column fill-column))
	 (old-fill-column fill-column)
	 (hash (unless fewer-lines
		 (buffer-hash)))
	 (original-num-lines (when fewer-lines
			       (line-number-at-pos (point-max)))))
    (with-temp-buffer
      (delay-mode-hooks
	(funcall mode))
      (insert-buffer-substring source-buffer)
      (goto-char point)
      (cl-loop while (and (fill-paragraph)
			  (if fewer-lines
			      (= original-num-lines (line-number-at-pos (point-max)))
			    (string= hash (buffer-hash))))
	       ;; If filling doesn't change after 100 iterations, abort by returning nil.
	       if (&gt; (- fill-column old-fill-column) 100)
	       return nil
	       else do (cl-incf fill-column)
	       finally return fill-column))))
</pre>
</div>
</div>
</div>

<div id="outline-container-~iedit~" class="outline-3">
<h3 id="~iedit~"><code>iedit</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="iedit">iedit</span>&#xa0;<span class="refactoring">refactoring</span></span></h3>
<div class="outline-text-3" id="text-~iedit~">
<p>
These commands make <code>iedit-mode</code> a bit easier to use.
</p>
</div>

<div id="outline-container-~iedit-scoped~" class="outline-4">
<h4 id="~iedit-scoped~"><code>iedit-scoped</code></h4>
<div class="outline-text-4" id="text-~iedit-scoped~">
<p>
Call <code>iedit-mode</code> with function-local scope, or global scope if called with a universal prefix.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/iedit-scoped (orig-fn)
  "Call `iedit-mode' with function-local scope, or global scope if called with a universal prefix."
  (interactive)
  (pcase-exhaustive current-prefix-arg
    ('nil (funcall orig-fn '(0)))
    ('(4) (funcall orig-fn))))

(advice-add #'iedit-mode :around #'unpackaged/iedit-scoped)
</pre>
</div>
</div>
</div>

<div id="outline-container-~iedit-or-flyspell~" class="outline-4">
<h4 id="~iedit-or-flyspell~"><code>iedit-or-flyspell</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="flyspell">flyspell</span>&#xa0;<span class="spell_checking">spell_checking</span></span></h4>
<div class="outline-text-4" id="text-~iedit-or-flyspell~">
<p>
Toggle <code>iedit-mode</code> or correct previous misspelling with <code>flyspell</code>, depending on context.
</p>

<p>
With point in code or when <code>iedit-mode</code> is already active, toggle <code>iedit-mode</code>.  With point in a comment or string, and when <code>iedit-mode</code> is not already active, auto-correct previous misspelled word with <code>flyspell</code>.  Call this command a second time to choose a different correction.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defvar flyspell-previous-command)

;;;###autoload
(defun unpackaged/iedit-or-flyspell ()
  "Toggle `iedit-mode' or correct previous misspelling with `flyspell', depending on context.

With point in code or when `iedit-mode' is already active, toggle
`iedit-mode'.  With point in a comment or string, and when
`iedit-mode' is not already active, auto-correct previous
misspelled word with `flyspell'.  Call this command a second time
to choose a different correction."
  (interactive)
  (if (or (bound-and-true-p iedit-mode)
	  (and (derived-mode-p 'prog-mode)
	       (not (or (nth 4 (syntax-ppss))
			(nth 3 (syntax-ppss))))))
      ;; prog-mode is active and point is in a comment, string, or
      ;; already in iedit-mode
      (call-interactively #'iedit-mode)
    ;; Not prog-mode or not in comment or string
    (if (not (equal flyspell-previous-command this-command))
	;; FIXME: This mostly works, but if there are two words on the
	;; same line that are misspelled, it doesn't work quite right
	;; when correcting the earlier word after correcting the later
	;; one

	;; First correction; autocorrect
	(call-interactively 'flyspell-auto-correct-previous-word)
      ;; First correction was not wanted; use popup to choose
      (progn
	(save-excursion
	  (undo)) ; This doesn't move point, which I think may be the problem.
	(flyspell-region (line-beginning-position) (line-end-position))
	(call-interactively 'flyspell-correct-previous-word-generic)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Sort%20sexps" class="outline-3">
<h3 id="Sort%20sexps">Sort sexps</h3>
<div class="outline-text-3" id="text-Sort%20sexps">
<p>
Sort sexps in region.  Comments stay with the code below.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/sort-sexps (beg end)
  "Sort sexps in region.
Comments stay with the code below."
  (interactive "r")
  (cl-flet ((skip-whitespace () (while (looking-at (rx (1+ (or space "\n"))))
				  (goto-char (match-end 0))))
	    (skip-both () (while (cond ((or (nth 4 (syntax-ppss))
					    (ignore-errors
					      (save-excursion
						(forward-char 1)
						(nth 4 (syntax-ppss)))))
					(forward-line 1))
				       ((looking-at (rx (1+ (or space "\n"))))
					(goto-char (match-end 0)))))))
    (save-excursion
      (save-restriction
	(narrow-to-region beg end)
	(goto-char beg)
	(skip-both)
	(cl-destructuring-bind (sexps markers)
	    (cl-loop do (skip-whitespace)
		     for start = (point-marker)
		     for sexp = (ignore-errors
				  (read (current-buffer)))
		     for end = (point-marker)
		     while sexp
		     ;; Collect the real string, then one used for sorting.
		     collect (cons (buffer-substring (marker-position start) (marker-position end))
				   (save-excursion
				     (goto-char (marker-position start))
				     (skip-both)
				     (buffer-substring (point) (marker-position end))))
		     into sexps
		     collect (cons start end)
		     into markers
		     finally return (list sexps markers))
	  (setq sexps (sort sexps (lambda (a b)
				    (string&lt; (cdr a) (cdr b)))))
	  (cl-loop for (real . sort) in sexps
		   for (start . end) in markers
		   do (progn
			(goto-char (marker-position start))
			(insert-before-markers real)
			(delete-region (point) (marker-position end)))))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Regular%20expressions" class="outline-2">
<h2 id="Regular%20expressions">Regular expressions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="regular_expressions">regular_expressions</span></span></h2>
<div class="outline-text-2" id="text-Regular%20expressions">
</div>
<div id="outline-container-query-replace-rx" class="outline-3">
<h3 id="query-replace-rx">query-replace-rx</h3>
<div class="outline-text-3" id="text-query-replace-rx">
<p>
Call <code>query-replace-regexp</code>, reading regexp in <code>rx</code> syntax.  Automatically wraps in parens and adds <code>seq</code> to the beginning of the form.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/query-replace-rx (&amp;rest _)
  "Call `query-replace-regexp', reading regexp in `rx' syntax.
Automatically wraps in parens and adds `seq' to the beginning of
the form."
  (interactive)
  (cl-letf (((symbol-function #'query-replace-read-from) (lambda (&amp;rest _)
							   (--&gt; (read-string "rx form: ")
								(concat "'(seq " it ")")
								(read it)
								(cadr it)
								(rx-to-string it)))))
    (call-interactively #'query-replace-regexp)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Version%20control" class="outline-2">
<h2 id="Version%20control">Version control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="version_control">version_control</span></span></h2>
<div class="outline-text-2" id="text-Version%20control">
</div>
<div id="outline-container-Magit" class="outline-3">
<h3 id="Magit">Magit&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Magit">Magit</span></span></h3>
<div class="outline-text-3" id="text-Magit">
</div>
<div id="outline-container-Improved%20~magit-status~%20command" class="outline-4">
<h4 id="Improved%20~magit-status~%20command">Improved <code>magit-status</code> command</h4>
<div class="outline-text-4" id="text-Improved%20~magit-status~%20command">
<p>
Open a <code>magit-status</code> buffer and close the other window so only Magit is visible.  If a file was visited in the buffer that was active when this command was called, go to its unstaged changes section.
</p>

<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/magit-status ()
  "Open a `magit-status' buffer and close the other window so only Magit is visible.
If a file was visited in the buffer that was active when this
command was called, go to its unstaged changes section."
  (interactive)
  (let* ((buffer-file-path (when buffer-file-name
			     (file-relative-name buffer-file-name
						 (locate-dominating-file buffer-file-name ".git"))))
	 (section-ident `((file . ,buffer-file-path) (unstaged) (status))))
    (call-interactively #'magit-status)
    (delete-other-windows)
    (when buffer-file-path
      (goto-char (point-min))
      (cl-loop until (when (equal section-ident (magit-section-ident (magit-current-section)))
		       (magit-section-show (magit-current-section))
		       (recenter)
		       t)
	       do (condition-case nil
		      (magit-section-forward)
		    (error (cl-return (magit-status-goto-initial-section-1))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-magit-log%20date%20headers" class="outline-4">
<h4 id="magit-log%20date%20headers">magit-log date headers</h4>
<div class="outline-text-4" id="text-magit-log%20date%20headers">
<p>
Add date headers to Magit log buffers.
</p>

<p>
<b>Requires:</b>
</p>
<ul class="org-ul">
<li><a href="https://github.com/ShingoFukuyama/ov.el">ov.el</a></li>
</ul>

<p>

</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun unpackaged/magit-log--add-date-headers (&amp;rest _ignore)
  "Add date headers to Magit log buffers."
  (when (derived-mode-p 'magit-log-mode)
    (save-excursion
      (ov-clear 'date-header t)
      (goto-char (point-min))
      (cl-loop with last-age
	       for this-age = (-some--&gt; (ov-in 'before-string 'any (line-beginning-position) (line-end-position))
					car
					(overlay-get it 'before-string)
					(get-text-property 0 'display it)
					cadr
					(s-match (rx (group (1+ digit) ; number
							    " "
							    (1+ (not blank))) ; unit
						     (1+ blank) eos)
						 it)
					cadr)
	       do (when (and this-age
			     (not (equal this-age last-age)))
		    (ov (line-beginning-position) (line-beginning-position)
			'after-string (propertize (concat " " this-age "\n")
						  'face 'magit-section-heading)
			'date-header t)
		    (setq last-age this-age))
	       do (forward-line 1)
	       until (eobp)))))

(define-minor-mode unpackaged/magit-log-date-headers-mode
  "Display date/time headers in `magit-log' buffers."
  :global t
  (if unpackaged/magit-log-date-headers-mode
      (progn
	;; Enable mode
	(add-hook 'magit-post-refresh-hook #'unpackaged/magit-log--add-date-headers)
	(advice-add #'magit-setup-buffer-internal :after #'unpackaged/magit-log--add-date-headers))
    ;; Disable mode
    (remove-hook 'magit-post-refresh-hook #'unpackaged/magit-log--add-date-headers)
    (advice-remove #'magit-setup-buffer-internal #'unpackaged/magit-log--add-date-headers)))
</pre>
</div>

<p>
This isn't always perfect, because dates in a git commit log are not always in order (e.g. when commits are merged at a later date), but it's often very helpful to visually group commits by their age.
</p>
</div>
</div>

<div id="outline-container-Save%20buffer%20and%20show%20changes%20in%20Magit%20status" class="outline-4">
<h4 id="Save%20buffer%20and%20show%20changes%20in%20Magit%20status">Save buffer and show changes in Magit status</h4>
<div class="outline-text-4" id="text-Save%20buffer%20and%20show%20changes%20in%20Magit%20status">
<div class="org-src-container">
<pre class="src src-elisp">;;;###autoload
(defun unpackaged/magit-save-buffer-show-status ()
  "Save buffer and show its changes in `magit-status'."
  (interactive)
  (save-buffer)
  (unpackaged/magit-status))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-~smerge-mode~" class="outline-3">
<h3 id="~smerge-mode~"><code>smerge-mode</code></h3>
<div class="outline-text-3" id="text-~smerge-mode~">
</div>

<div id="outline-container-Hydra" class="outline-4">
<h4 id="Hydra">Hydra</h4>
<div class="outline-text-4" id="text-Hydra">
<p>
This configuration automatically activates a helpful <code>smerge-mode</code> hydra when a file containing merge conflicts is visited from a Magit diff section.  You can manually activate the hydra with the command <code>unpackaged/smerge-hydra/body</code>.  (Inspired by <a href="https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-diff.el">Kaushal Modi's Emacs config</a>.)
</p>

<p>
<b>Requires</b>:
</p>
<ul class="org-ul">
<li><a href="https://github.com/abo-abo/hydra">hydra</a></li>
<li><a href="https://magit.vc/">Magit</a></li>
</ul>

<p>

</p>

<p>
See these screencasts comparing what it's like to resolve the conflict with and with this .
</p>

<div class="org-src-container">
<pre class="src src-elisp">(require 'hydra)

(use-package smerge-mode
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _&lt;_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _&gt;_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("&lt;" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    ("&gt;" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
	    (interactive)
	    (save-buffer)
	    (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  :hook (magit-diff-visit-file . (lambda ()
				   (when smerge-mode
				     (unpackaged/smerge-hydra/body)))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-Web" class="outline-2">
<h2 id="Web">Web&#xa0;&#xa0;&#xa0;<span class="tag"><span class="web">web</span></span></h2>
<div class="outline-text-2" id="text-Web">
</div>
<div id="outline-container-feed-for-url" class="outline-3">
<h3 id="feed-for-url">feed-for-url&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RSS">RSS</span>&#xa0;<span class="Atom">Atom</span>&#xa0;<span class="XML">XML</span></span></h3>
<div class="outline-text-3" id="text-feed-for-url">
<p>
Return ATOM or RSS feed <code>URL</code> for web page at <code>URL</code>.  Interactively, insert the <code>URL</code> at point.  <code>PREFER</code> may be <code>atom</code> (the default) or <code>rss</code>.  When <code>ALL</code> is non-nil, return all feed URLs of all types; otherwise, return only one feed <code>URL</code>, preferring the preferred type.
</p>

<p>
<b>Requires:</b>
</p>
<ul class="org-ul">
<li><a href="https://github.com/tali713/esxml">esxml</a></li>
<li><a href="https://github.com/alphapapa/org-web-tools">org-web-tools</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-elisp">(eval-when-compile
  (require 'esxml-query))

;;;###autoload
(cl-defun unpackaged/feed-for-url (url &amp;key (prefer 'atom) (all nil))
  "Return feed URL for web page at URL.
Interactively, insert the URL at point.  PREFER may be
`atom' (the default) or `rss'.  When ALL is non-nil, return all
feed URLs of all types; otherwise, return only one feed URL,
preferring the preferred type."
  (interactive (list (org-web-tools--get-first-url)))
  (require 'esxml-query)
  (require 'org-web-tools)
  (cl-flet ((feed-p (type)
		    ;; Return t if TYPE appears to be an RSS/ATOM feed
		    (string-match-p (rx "application/" (or "rss" "atom") "+xml")
				    type)))
    (let* ((preferred-type (format "application/%s+xml" (symbol-name prefer)))
	   (html (org-web-tools--get-url url))
	   (dom (with-temp-buffer
		  (insert html)
		  (libxml-parse-html-region (point-min) (point-max))))
	   (potential-feeds (esxml-query-all "link[rel=alternate]" dom))
	   (return (if all
		       ;; Return all URLs
		       (cl-loop for (_tag attrs) in potential-feeds
				when (feed-p (alist-get 'type attrs))
				collect (url-expand-file-name (alist-get 'href attrs) url))
		     (or
		      ;; Return the first URL of preferred type
		      (cl-loop for (_tag attrs) in potential-feeds
			       when (equal preferred-type (alist-get 'type attrs))
			       return (url-expand-file-name (alist-get 'href attrs) url))
		      ;; Return the first URL of non-preferred type
		      (cl-loop for (_tag attrs) in potential-feeds
			       when (feed-p (alist-get 'type attrs))
			       return (url-expand-file-name (alist-get 'href attrs) url))))))
      (if (called-interactively-p 'interactive)
	  (insert (if (listp return)
		      (s-join " " return)
		    return))
	return))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-License" class="outline-2">
<h2 id="License">License</h2>
<div class="outline-text-2" id="text-License">
<p>
GPLv3
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2021-09-25 Sat 02:24</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
